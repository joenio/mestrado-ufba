"http://ieeexplore.ieee.org/search/searchresult.jsp?bulkSetSize=57&matchBoolean%3Dtrue%26rowsPerPage%3D50%26searchField%3DSearch_All%26queryText%3D%28%28%28%28%28static%29+AND+code%29+AND+analysis%29+AND+software%29+AND+visualization%29",2014/10/23 18:15:41
"Document Title",Authors,"Author Affiliations","Publication Title","Publication Date","Publication Year","Volume","Issue","Start Page","End Page","Abstract","ISSN","ISBN","EISBN","DOI",PDF Link,"Author Keywords","IEEE Terms","INSPEC Controlled Terms","INSPEC Non-Controlled Terms","DOE Terms","PACS Terms","MeSH Terms",Article Citation Count,Patent Citation Count,"Reference Count","Copyright Year","Online Date",Date Added To Xplore,"Meeting Date","Publisher","Sponsors",Document Identifier
"ClonEvol: Visualizing software evolution with code clones","Hanjalic, A.","Dept. of Comput. Sci., Univ. of Groningen, Groningen, Netherlands","Software Visualization (VISSOFT), 2013 First IEEE Working Conference on","27-28 Sept. 2013","2013","","","1","4","We present ClonEvol, a visual analysis tool that assists in obtaining insight into the state and the evolution of a C/C++/Java source code base on project, file and scope level. ClonEvol combines information obtained from the software versioning system and contents of files that change between versions; The tool operates as tool-chain of Subversion (SVN), Doxygen (applied as static analyzer) and Simian as code duplication detector. The consolidated information is presented to the user in an interactive visual manner. The focus of the presented tool lies on scalability (in time and space) concerning data acquisition, data processing and visualization, and ease of use. The visualization is approached by using a (mirrored) radial tree to show the file and scope structures, complemented with hierarchically bundled edges that show clone relations. We demonstrate the use of ClonEvol on a real world code base.","","","","10.1109/VISSOFT.2013.6650525","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6650525","Code Clones;Software Evolution Analysis;Software Visualization","Cloning;Data mining;Data visualization;Java;Scalability;Software;Visualization","configuration management;data visualisation;software engineering","C source code;C++ source code;ClonEvol visual analysis tool;Doxygen;Java source code;Simian;clone relations;code clones;code duplication detector;data acquisition;data processing;data visualization;file structures;radial tree;scope structures;software evolution visualization;software versioning system;subversion tool-chain","","","","0","","11","","","20131031","","IEEE","","IEEE Conference Publications"
"Magnify - A new tool for software visualization","Bartoszuk, C.; Timoszuk, G.; Dabrowski, R.; Stencel, K.","Inst. of Inf., Univ. of Warsaw, Warsaw, Poland","Computer Science and Information Systems (FedCSIS), 2013 Federated Conference on","8-11 Sept. 2013","2013","","","1485","1488","Modern software systems are inherently complex. Their maintenance is hardly possible without precise up-to-date documentation. It is often tricky to document dependencies among software components by only looking at the raw source code. We address these issues by researching new software analysis and visualization tools. In this paper we focus on software visualisation. Magnify is our new tool that performs static analysis and visualization of software. It parses the source code, identifies dependencies between code units and records all the collected information in a repository based on a language-independent graph-based data model. Nodes of the graph correspond to program entities of disparate granularity: methods, classes, packages etc. Edges represent dependencies and hierarchical structure. We use colours to reflect the quality, sizes to display the importance of artefacts, density of connections to portray the coupling. This kind of visualization gives bird's-eye view of the source code. It is always up to date, since the tool generates it automatically from the current revision of software. In this paper we discuss the design of the tool and present visualizations of sample open-source Java projects of various sizes.","","","","","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6644213","","Computer architecture;Data visualization;Java;Measurement;Software;Unified modeling language;Visualization","data models;graph theory;program diagnostics;program visualisation;software tools","Magnify tool;document dependency;hierarchical structure;language-independent graph-based data model;open-source Java projects;raw source code;software analysis;software components;software maintenance;software systems;software visualization tools","","","","0","","20","","","20131107","","IEEE","","IEEE Conference Publications"
"IMMV: An interactive multi-matrix visualization for program comprehension","Abuthawabeh, A.; Zeckzer, D.","Tech. Univ. Kaiserslautern, Kaiserslautern, Germany","Software Visualization (VISSOFT), 2013 First IEEE Working Conference on","27-28 Sept. 2013","2013","","","1","4","Many visualization techniques are used by software engineers to understand and to analyze the static structure of software systems, with the static structure being extracted from the source code. However, the need for scalable visualizations, which take into account the increasing number of code entities (classes and interfaces) and different types of code couplings (relations between them) in software systems, is still not sufficiently fulfilled. In this paper, we extend the design of an existing multi-matrix visualization approach to represent the static structure of software systems in a scalable way. First, we extended the data model and the algorithms. Second, we added more visualization and interaction elements. Finally, we incorporated the folding (collapsing) and the unfolding (expanding) of the package hierarchy, which have quadratic time complexity and quadratic space complexity in the number of nodes. This extended approach can be applied to support program comprehension and to analyze the static structure of software systems.","","","","10.1109/VISSOFT.2013.6650549","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6650549","","Algorithm design and analysis;Color;Complexity theory;Couplings;Software systems;Visualization","computational complexity;data visualisation;matrix algebra;program diagnostics","IMMV;code couplings;code entities;interaction elements;interactive multimatrix visualization;package hierarchy;program comprehension;quadratic space complexity;quadratic time complexity;scalable visualizations;software engineers;source code;static software systems structure;visualization elements;visualization techniques","","","","1","","13","","","20131031","","IEEE","","IEEE Conference Publications"
"The CONCEPT project - applying source code analysis to reduce information complexity of static and dynamic visualization techniques","Rilling, J.; Seffah, A.; Bouthlier, C.","Dept. of Comput. Sci., Concordia Univ., Montreal, Que., Canada","Visualizing Software for Understanding and Analysis, 2002. Proceedings. First International Workshop on","2002","2002","","","90","99","The goal of software visualization is to acquire sufficient knowledge about a software system by identifying program artifacts and understanding their relationships. Graphical representations have long been recognized as having an important impact in improving the comprehension of source code. In this paper, we present several visualization techniques that we combine with analytical source code analysis to reduce the amount and, therefore, the complexity of data that has to be displayed. In particular, we focus on static and dynamic program slicing and apply this source code analysis technique on tree maps, hyperbolic trees, and UML based visualization techniques to support programmers in creating better mental models of the source code. We also introduce our CONCEPT prototype and describe how the presented approaches can be applied to reduce the information complexity for particular source code comprehension applications.","","0-7695-1662-9","","10.1109/VISSOF.2002.1019798","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1019798","","Cognitive science;Computer displays;Computer science;Data visualization;Human computer interaction;Information analysis;Programming profession;Prototypes;Software systems;Unified modeling language","data visualisation;program slicing;software engineering;trees (mathematics)","CONCEPT project;UML;graphical representations;hyperbolic trees;program slicing;software visualization;source code analysis;tree maps","","","","0","1","","","","20020807","","IEEE","","IEEE Conference Publications"
"A three-dimensional visualization tool for software fault analysis of a distributed system","Amari, H.; Okada, M.","Comput. & Commun. R&D Center, Tokyo Electr. Power Co. Inc., Japan","Systems, Man, and Cybernetics, 1999. IEEE SMC '99 Conference Proceedings. 1999 IEEE International Conference on","1999","1999","4","","194","199 vol.4","We propose a software visualization tool named Software Visualization Supporting Space (SVSS) utilizing three-dimensional (3D) graphics in order to detect and analyze software faults in a large-scale distributed system. When a failure occurs in a software testing process, it is necessary for fault detection to inspect a large number of software processes from various viewpoints. 3D graphical representations allow a greater quantity of data as well as complex structures and relationships between components to be displayed on the screen effectively. SVSS can analyze the source code regularly to generate structural data of the target software. Moreover, it can also analyze the behavior of the processes using trace data obtained automatically by embedding a trace data acquisition function in the target machine. The results of these analysis functions can be visualized collectively on a common display so that the developer can trace execution flows and static connections simultaneously. The work reduction ratio using SVSS was estimated by sampling faults that had occurred in practical development of a distributed power control system","1062-922X","0-7803-5731-0","","10.1109/ICSMC.1999.812399","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=812399","","Data acquisition;Data visualization;Displays;Fault detection;Graphics;Large-scale systems;Power control;Sampling methods;Software testing;Software tools","data acquisition;distributed processing;power control;program debugging;program testing;program visualisation","3D graphics;Software Visualization Supporting Space;distributed power control system;distributed system;fault detection;sampling faults;software fault analysis;software testing;software visualization tool;source code;three-dimensional visualization tool;trace data acquisition function","","","","0","","11","","","20020806","12 Oct 1999-15 Oct 1999","IEEE","","IEEE Conference Publications"
"Identifying Structural Features of Java Programs by Analysing the Interaction of Classes at Runtime","Smith, M.P.; Munro, M.","Dept. of Comput. Sci., Durham Univ.","Visualizing Software for Understanding and Analysis, 2005. VISSOFT 2005. 3rd IEEE International Workshop on","0-0 0","2005","","","1","1","This paper describes research on visualising Java software at runtime in order to enable the identification of structural features. The aim is to highlight both the static and dynamic structure of the software and aid software engineers in tasks requiring program comprehension of the code. The paper takes the position that this type of analysis and visualisation for object oriented languages must be carried out with dynamic runtime information and that it cannot, in general, be obtained by static analysis alone. A case study is worked through to demonstrate the approach","","0-7803-9540-9","","10.1109/VISSOF.2005.1684316","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1684316","","Information analysis;Java;Programming profession;Runtime;Software debugging;Software engineering;Software maintenance;Software systems;Software testing;Visualization","Java;data flow analysis;program visualisation","Java programs;Java software visualisation;class interaction analysis;dynamic runtime information;object oriented languages;program code comprehension;software dynamic structure;software static structure;static analysis;structural feature identification","","","","0","5","8","","","20061009","","IEEE","","IEEE Conference Publications"
"Animated Visualization of Software History using Evolution Storyboards","Beyer, D.; Hassan, A.E.","EPFL","Reverse Engineering, 2006. WCRE '06. 13th Working Conference on","Oct. 2006","2006","","","199","210","The understanding of the structure of a software system can be improved by analyzing the system's evolution during development. Visualizations of software history that provide only static views do not capture the dynamic nature of software evolution. We present a new visualization technique, the Evolution Storyboard, which provides dynamic views of the evolution of a software's structure. An evolution storyboard consists of a sequence of animated panels, which highlight the structural changes in the system; one panel for each considered time period. Using storyboards, engineers can spot good design, signs of structural decay, or the spread of cross cutting concerns in the code. We implemented our concepts in a tool, which automatically extracts software dependency graphs from version control repositories and computes storyboards based on panels for different time periods. For applying our approach in practice, we provide a step by step guide that others can follow along the storyboard visualizations, in order to study the evolution of large systems. We have applied our method to several large open source software systems. In this paper, we demonstrate that our method provides additional information (compared to static views) on the ArgoUML project, an open source UML modeling tool","1095-1350","0-7695-2719-1","","10.1109/WCRE.2006.14","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4023990","","Animation;Automatic control;Data mining;Design engineering;History;Motion pictures;Software engineering;Software systems;Software tools;Visualization","Unified Modeling Language;computer animation;data visualisation;graph theory;program diagnostics;software reviews","ArgoUML project;UML modeling tool;animated visualization;evolution storyboards;open source software systems;software dependency graphs;software evolution;software history;software structure;software system;storyboard visualizations;version control repository;visualization technique","","","","15","","17","","","20061211","","IEEE","","IEEE Conference Publications"
"Viewing Object-Oriented Software with MetricAttitude: An Empirical Evaluation","Francese, R.; Risi, M.; Scanniello, G.; Tortora, G.","Univ. of Salerno, Salerno, Italy","Information Visualisation (IV), 2014 18th International Conference on","16-18 July 2014","2014","","","59","64","MetricAttitude is a visualization tool based on static analysis that provides a mental picture by viewing an object-oriented software system by means of polymetric views. In this paper, we present a preliminary empirical investigation based on a questionnaire-based survey to assess Metric Attitude with respect to source code comprehension tasks. Participants involved in this study were Computer Science students and software professionals. The results suggest that Metric Attitude is a viable means to comprehend source code and that both kinds of participants in the empirical investigation considered it to be appropriate in source code comprehension.","1550-6037","","","10.1109/IV.2014.42","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6902881","Program Comprehension;Reverse Engineering;Software Maintenance;Software Metrics;Software Visualization Tool","Abstracts;Color;Layout;Measurement;Software systems;Visualization","object-oriented methods;program diagnostics;program visualisation;source code (software)","MetricAttitude;computer science students;object-oriented software system;polymetric views;preliminary empirical investigation;questionnaire-based survey;software professionals;software visualization tool;source code comprehension;source code comprehension tasks;static analysis","","","","","","","","","20140922","","IEEE","","IEEE Conference Publications"
"Case study: Visual analytics in software product assessments","Telea, A.; Voinea, L.","Inst. for Math. & Comput. Sci., Univ. of Groningen, Groningen, Netherlands","Visualizing Software for Understanding and Analysis, 2009. VISSOFT 2009. 5th IEEE International Workshop on","25-26 Sept. 2009","2009","","","65","72","We present how a combination of static source code analysis, repository analysis, and visualization techniques has been used to effectively get and communicate insight in the development and project management problems of a large industrial code base. This study is an example of how visual analytics can be effectively applied to answer maintenance questions and support decision making in the software industry. We comment on the relevant findings during the study both in terms of used technique and applied methodology and outline the favorable factors that were essential in making this type of assessment successful within tight time and budget constraints.","","978-1-4244-5027-5","978-1-4244-5026-8","10.1109/VISSOF.2009.5336417","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5336417","","Cement industry;Computer architecture;Computer industry;Concrete;Data analysis;Data visualization;Documentation;Embedded software;Project management;Visual analytics","data visualisation;decision making;program diagnostics;program visualisation;project management;software maintenance","decision making;industrial code base;project management problems;repository analysis;software industry;software maintenance;software product assessment;static source code analysis;visual analytics;visualization techniques","","","","4","","18","","","20091117","","IEEE","","IEEE Conference Publications"
"Seesoft-a tool for visualizing line oriented software statistics","Eick, S.G.; Steffen, J.L.; Sumner, E.E., Jr.","AT&T Bell Lab., Naperville, IL, USA","Software Engineering, IEEE Transactions on","Nov 1992","1992","18","11","957","968","The Seesoft software visualization system allows one to analyze up to 50000 lines of code simultaneously by mapping each line of code into a thin row. The color of each row indicates a statistic of interest, e.g., red rows are those most recently changed, and blue are those least recently changed. Seesoft displays data derived from a variety of sources, such as version control systems that track the age, programmer, and purpose of the code (e.g., control ISDN lamps, fix bug in call forwarding); static analyses, (e.g., locations where functions are called); and dynamic analyses (e.g., profiling). By means of direct manipulation and high interaction graphics, the user can manipulate this reduced representation of the code in order to find interesting patterns. Further insight is obtained by using additional windows to display the actual code. Potential applications for Seesoft include discovery, project management, code tuning, and analysis of development methodologies","0098-5589","","","10.1109/32.177365","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=177365","","Control systems;Data visualization;Displays;ISDN;Lamps;Programming profession;Simultaneous localization and mapping;Software systems;Software tools;Statistics","configuration management;data visualisation;project management;software tools","ISDN lamps;Seesoft;call forwarding;code tuning;development methodologies;direct manipulation;discovery;dynamic analyses;high interaction graphics;line oriented software statistics;project management;software visualization system;static analyses;tool;version control systems","","","","98","18","20","","","20020806","","IEEE","IEEE Computer Society","IEEE Journals & Magazines"
"Runtime visualisation of object oriented software","Smith, M.P.; Munro, M.","Dept. of Comput. Sci., Durham Univ., UK","Visualizing Software for Understanding and Analysis, 2002. Proceedings. First International Workshop on","2002","2002","","","81","89","Software is inherently dynamic, yet much of the analysis and comprehension processes focus entirely on the static source code of the software. This paper looks at how software visualisation offers a way to aid comprehension by displaying both static and dynamic aspects of a piece of software. A new visualisation is presented with specific focus on a class level summary view.","","0-7695-1662-9","","10.1109/VISSOF.2002.1019797","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1019797","","Computer errors;Computer science;Documentation;Information resources;Java;Runtime;Software maintenance;Software systems;Software tools;Visualization","data visualisation;object-oriented programming;software engineering","Java programs;object oriented programming;runtime View;runtime visualisation;software visualisation;static source code","","","","4","6","","","","20020807","","IEEE","","IEEE Conference Publications"
"Monitoring compliance of a software system with its high-level design models","Sefika, M.; Sane, A.; Campbell, R.H.","Dept. of Comput. Sci., Illinois Univ., Urbana, IL, USA","Software Engineering, 1996., Proceedings of the 18th International Conference on","25-29 Mar 1996","1996","","","387","396","As a complex software system evolves, its implementation tends to diverge from the intended or documented design models. Such undesirable deviation makes the system hard to understand, modify and maintain. This paper presents a hybrid computer-assisted approach for confirming that the implementation of a system maintains its expected design models and rules. Our approach closely integrates logic-based static analysis and dynamic visualization, providing multiple code views and perspectives. We show that the hybrid technique helps determine design-implementation congruence at various levels of abstraction: concrete rules like coding guidelines, architectural models like design patterns or connectors, and subjective design principles like low coupling and high cohesion. The utility of our approach has been demonstrated in the development of μChoices, a new multimedia operating system which inherits many design decisions and guidelines learned from experience in the construction and maintenance of its predecessor, Choices","0270-5257","0-8186-7247-1","","10.1109/ICSE.1996.493433","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=493433","","Computer science;Computerized monitoring;Concrete;Guidelines;Multimedia systems;Operating systems;Software systems;Utility programs;Visualization;World Wide Web","conformance testing;monitoring;multimedia computing;operating systems (computers);software engineering","μChoices;abstraction levels;architectural models;coding guidelines;complex software system evolution;concrete rules;connectors;design patterns;design-implementation congruence;documented design models;dynamic visualization;high cohesion;high-level design models;hybrid computer-assisted approach;implementation divergence;logic-based static analysis;low coupling;multimedia operating system;multiple code view;software system compliance monitoring;subjective design principles","","","","28","2","26","","","20020806","25 Mar 1996-30 Mar 1996","IEEE","","IEEE Conference Publications"
"Visualization of C++ Template Metaprograms","Boro&#x0301;k-Nagy, Z.; Ma&#x0301;jer, V.; Mihalicza, J.; Pataki, N.; Porkolab, Z.","Dept. of Programming Languages & Compilers, Eotvos Lorand Univ., Budapest, Hungary","Source Code Analysis and Manipulation (SCAM), 2010 10th IEEE Working Conference on","12-13 Sept. 2010","2010","","","167","176","Template metaprograms have become an essential part of today's C++ programs: with proper template definitions we can force the C++ compiler to execute algorithms at compilation time. Among the application areas of template metaprograms are the expression templates, static interface checking, code optimization with adaptation, language embedding and active libraries. Despite all of its already proven benefits and numerous successful applications there are surprisingly few tools for creating, supporting, and analyzing C++ template metaprograms. As metaprograms are executed at compilation time they are even harder to understand. In this paper we present a code visualization tool, which is utilizing Tem plight, our previously developed C++ template metaprogram debugger. Using the tool it is possible to visualize the instantiation chain of C++ templates and follow the execution of metaprograms. Various presentation layers, filtering of template instances and step-by-step replay of the instantiations are supported. Our tool can help to test, optimize, maintain C++ template metaprograms, and can enhance their acceptance in the software industry.","","978-1-4244-8655-7","","10.1109/SCAM.2010.16","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5601850","C++ template metaprogram;code comprehension","Context;Data structures;Debugging;Instruments;Libraries;Programming;Visualization","C++ language;data visualisation;program compilers;program debugging","C++ compiler;C++ template metaprogram debugger;C++ template metaprogram visualization;active libraries;code optimization;code visualization tool;expression templates;language embedding;static interface checking;tem plight","","","","0","","","","","20101014","","IEEE","","IEEE Conference Publications"
"Extendable object visualisation for software reengineering","Muhlbacher, J.R.; Dietmuller, P.R.; Jobstl, M.","Dept. of Inf. Process. & Microtechnol. Technol., Johannes Kepler Univ., Linz, Austria","EUROMICRO Conference, 1999. Proceedings. 25th","1999","1999","2","","229","236 vol.2","This paper describes an experimental reengineering tool which assists the process of understanding the functionality of unknown software, particularly object oriented programs. In contrast to many other tools which analyse the source code, the inspected program is analysed at runtime by a concurrent process running in parallel. Information on all objects allocated by the inspected program is collected, in particular the dynamic type of each inspected object is determined. In contrast to the static type, the dynamic type of an object can only be determined at runtime. Each object is visualised by a corresponding visualisation class. Visualisation classes for well known data structures like binary trees can be used from the beginning. New visualisation can be derived by class extensions or can be added simply. The inspected program can be halted at specific locations to update the visualisation. Also, updating the visualisation can be triggered by specifying watch points","1089-6503","0-7695-0321-7","","10.1109/EURMIC.1999.794785","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=794785","","Binary trees;Data structures;Data visualization;Documentation;Information processing;Microprocessors;Runtime;Software tools;Tree data structures;Watches","object-oriented programming;program visualisation;systems re-engineering","data structures;dynamic type;functionality;object oriented programs;object visualisation;software reengineering;visualisation class","","","","0","","14","","","20020806","08 Sep 1999-10 Sep 1999","IEEE","","IEEE Conference Publications"
"Visualizing Feature Interaction in 3-D","Greevy, O.; Lanza, M.; Wysseier, C.","Berne Univ.","Visualizing Software for Understanding and Analysis, 2005. VISSOFT 2005. 3rd IEEE International Workshop on","0-0 0","2005","","","1","6","Without a clear understanding of how features of a software system are implemented, a maintenance change in one part of the code may risk adversely affecting other features. Feature implementation and relationships between features are not explicit in the code. To address this problem, we propose an interactive 3D visualization technique based on a combination of static and dynamic analysis which enables the software developer to step through visual representations of execution traces. We visualize dynamic behaviors of execution traces in terms of object creations and interactions and represent this in the context of a static class-hierarchy view of a system. We describe how we apply our approach to a case study to visualize and identify common parts of the code that are active during feature execution","","0-7803-9540-9","","10.1109/VISSOF.2005.1684317","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1684317","","Control systems;Engines;Informatics;Information analysis;Reverse engineering;Runtime;Software maintenance;Software systems;Terminology;Visualization","computer graphics;program diagnostics;program visualisation;software maintenance","dynamic analysis;dynamic behavior visualization;execution traces;feature execution;feature implementation;feature interaction;interactive 3D visualization;maintenance change;object creations;object interactions;software system;static analysis;static class-hierarchy system view;visual representations","","","","3","","20","","","20061009","","IEEE","","IEEE Conference Publications"
"Design of a parser for real-time process algebra","Jianhua Zhao; Wang, Yingxu","Inst. of Comput. Sci. & Technol., Nanjing Univ., China","Electrical and Computer Engineering, 2003. IEEE CCECE 2003. Canadian Conference on","4-7 May 2003","2003","2","","1259","1262 vol.2","The real-time process algebra (RTFA) is a set of new mathematical notations for formally describing software system architectures, and static and dynamic behaviors. To bring RTPA into industrial software development practice, tools are needed for analyzing and visualizing RTPA specifications. The first step to develop the supporting tools is to build a grammar parser for recognizing the RTPA notation system. In this paper, a parser of RTPA is described. The parser takes a textual RTPA specification as input, and generates an abstract syntax tree (AST) as its output. The generated AST represents RTPA tokens and lexical information in a structured format, which provides a foundation for further semantic analysis, code generation, visualization, and validation.","0840-7789","0-7803-7781-8","","10.1109/CCECE.2003.1226128","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1226128","","Algebra;Computer architecture;Computer industry;Computer science;Drives;Java;Real time systems;Software engineering;Software systems;Visualization","grammars;process algebra;real-time systems;software architecture;software tools","AST;RTFA;abstract syntax tree;grammar parser;real-time process algebra;software engineering;software system architecture;software tools","","","","3","","7","","","20030904","","IEEE","","IEEE Conference Publications"
"Analyzing Java software by combining metrics and program visualization","Systa, T.; Ping Yu; Muller, H.","Software Syst. Lab., Tampere Univ. of Technol., Finland","Software Maintenance and Reengineering, 2000. Proceedings of the Fourth European","Feb 2000","2000","","","199","208","Shimba, a prototype reverse engineering environment, has been built to support the understanding of Java software. Shimba uses Rigi and SCED to analyze, visualize, and explore the static and dynamic aspects, respectively, of the subject system. The static software artifacts and their dependencies are extracted from Java byte code and viewed as directed graphs using the Rigi reverse engineering environment. The static dependency graphs of a subject system can be annotated with attributes, such as software quality measures, and then be analyzed and visualised using scripts through the end user programmable interface. Shimba has recently been extended with the Chidamber and Kemerer suite of object oriented metrics. The metrics measure properties of the classes, the inheritance hierarchy, and the interaction among classes of a subject system. Since Shimba is primarily intended for the analysis and exploration of Java software, the metrics have been tailored to measure properties of software systems using a reverse engineering environment. The static dependency graphs of the system under investigation are decorated with measures obtained by applying the object oriented metrics to selected software components. Shimba provides tools to examine these measures, to find software artifacts that have values that are in a given range, and to detect correlations among different measures. The object oriented analysis of the subject Java system can be investigated further by exporting the measures to a spreadsheet","","0-7695-0546-5","","10.1109/CSMR.2000.827328","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=827328","","Computer science;Electrical capacitance tomography;Java;Laboratories;Prototypes;Read only memory;Reverse engineering;Software systems;Tail;Visualization","Java;directed graphs;inheritance;object-oriented programming;program visualisation;reverse engineering;software metrics;software quality","Chidamber;Java byte code;Java software;Kemerer suite;Rigi;Rigi reverse engineering environment;SCED;Shimba;directed graphs;dynamic aspects;end user programmable interface;inheritance hierarchy;metrics;object oriented analysis;object oriented metrics;program visualization;prototype reverse engineering environment;reverse engineering environment;software artifacts;software components;software quality measures;spreadsheet;static dependency graphs;static software artifacts;subject Java system;subject system","","","","11","3","25","","","20020806","29 Feb 2000-03 Mar 2000","IEEE","","IEEE Conference Publications"
"K-scope: A Java-Based Fortran Source Code Analyzer with Graphical User Interface for Performance Improvement","Terai, M.; Murai, H.; Minami, K.; Yokokawa, M.; Tomiyama, E.","RIKEN Adv. Inst. for Comput. Sci., Kobe, Japan","Parallel Processing Workshops (ICPPW), 2012 41st International Conference on","10-13 Sept. 2012","2012","","","434","443","Given that scientific computer programs are becoming larger and more complicated, high performance application developers routinely examine the program structure of their source code to improve their performance. We have developed K-scope, a source code analysis tool that can be used to improve code performance. K-scope has graphical user interface that visualizes program structures of Fortran 90 and FORTRAN 77 source code and enables static data-flow analysis. To develop the tool, we adopted the filtered abstract syntax tree (filtered-AST) model with Java to visualize the program structure efficiently. Filtered-AST, which extends the AST in the structured programming model by abstract block structuring, is suitable for visualization program structures. Based on this model, K-scope has been developed as an experimental implementation. It constructs filtered-AST objects from both source and intermediate code generated by the front-end of the XcalableMP compiler. We provide illustrations of the graphical user interface and give detailed examples of the tool applied to an actual application code.","1530-2016","978-1-4673-2509-7","","10.1109/ICPPW.2012.61","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6337511","GUI;XcalableMP compiler;filtered-AST;single core performance improvement;static source code analysis","Analytical models;Computational modeling;Load modeling;Object oriented modeling;Syntactics;Visualization;XML","FORTRAN;Java;computational linguistics;data flow analysis;graphical user interfaces;natural sciences computing;program compilers;program visualisation;software performance evaluation;source coding;structured programming;tree data structures","FORTRAN 77 source code;Fortran 90 source code;Java-based Fortran source code analyzer;K-scope;XcalableMP compiler;abstract block structuring;code performance improvement;filtered abstract syntax tree model;filtered-AST model;graphical user interface;high performance application developers;program structure visualization;scientific computer programs;source code analysis tool;static data flow analysis;structured programming model","","","","0","","20","","","20121025","","IEEE","","IEEE Conference Publications"
"Dynamic Analysis of Software Systems using Execution Pattern Mining","Safyallah, H.; Sartipi, K.","Dept. of Comput. & Software, McMaster Univ., Hamilton, Ont.","Program Comprehension, 2006. ICPC 2006. 14th IEEE International Conference on","0-0 0","2006","","","84","88","Software system analysis for extracting system functionality remains as a major problem in the reverse engineering literature and the early approaches mainly rely on static properties of software. In this paper, we propose a novel technique for dynamic analysis of software systems to identify the implementation of the software features that are specified through a number of feature-specific task scenarios. The execution of task scenarios and application of data mining algorithm sequential pattern discovery on the generated traces allow us to extract common functionality associated with the corresponding feature-specific task scenarios. The extracted patterns are used to identify the groups of core functions that implement software features. The proposed approach can be used for program comprehension and feature to source code assignment. A case study on the Unix Xfig drawing tool has been provided","1092-8138","0-7695-2601-2","","10.1109/ICPC.2006.19","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1631109","Dynamic Analysis;Execution;Feature Extraction.;Scenario;Sequential Pattern Mining;Trace","Application software;Data mining;Feature extraction;Optimization;Pattern analysis;Performance analysis;Reverse engineering;Software performance;Software systems;Visualization","data mining;program diagnostics;reverse engineering;systems analysis","Unix Xfig drawing tool;data mining;dynamic analysis;execution pattern mining;program comprehension;reverse engineering;sequential pattern discovery;software system analysis;source code assignment;system functionality extraction;task scenario execution","","","","13","1","11","","","20060626","","IEEE","","IEEE Conference Publications"
"A Combined Software Reconnaissance &amp; Static Analysis Eclipse Visualisation Plug-in","Cleary, B.; Le Gear, A.; Exton, C.; Buckley, J.","Dept. of Comput. Sci. & Inf. Syst., Univ. of Limerick","Visualizing Software for Understanding and Analysis, 2005. VISSOFT 2005. 3rd IEEE International Workshop on","0-0 0","2005","","","1","2","Software reconnaissance is a dynamic analysis technique which can aid in the mapping between program features and code that implements those features. In a previous case study we have shown how we were able to combine software reconnaissance with a static data analysis to a derive reuse perspective from an existing system. In this paper we report on the tool support, in the form of an eclipse plug-in, developed to aid in visualising the results of the combined dynamic and static analyses","","0-7803-9540-9","","10.1109/VISSOF.2005.1684319","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1684319","","Computer science;Data analysis;Data visualization;Gears;Information systems;Instruments;Reconnaissance;Software testing;Software tools;Spatial databases","program diagnostics;program visualisation","Eclipse visualisation plug-in;dynamic analysis;program code mapping;program feature mapping;software reconnaissance;static analysis;static data analysis;tool support","","","","1","","7","","","20061009","","IEEE","","IEEE Conference Publications"
"Support for Static Concept Location with sv3D","Xinrong Xie; Poshyvanyk, D.; Marcus, A.","Dept. of Comput. Sci., Wayne State Univ., Detroit, MI","Visualizing Software for Understanding and Analysis, 2005. VISSOFT 2005. 3rd IEEE International Workshop on","0-0 0","2005","","","1","6","The paper presents a new visualization approach to support static concept location in source code. The approach is realized through the combination of two existing tools: IRiSS, which is an information retrieval based tool that support source code searching and browsing; and sv3D, which is a software visualization front end. Both tools are integrated into MS Visual Studio .NET. The motivation behind the approach, the definition of the visual mappings, and usage examples are also presented in the paper, together with an outline of future and related work","","0-7803-9540-9","","10.1109/VISSOF.2005.1684315","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1684315","","Application software;Containers;Data visualization;Displays;Filtering;Information retrieval;Software engineering;Software metrics;Software systems;Software tools","data flow analysis;information retrieval;network operating systems;program visualisation;software engineering","IRiSS tool;MS Visual Studio .NET;information retrieval;software visualization front end;source code browsing;source code searching;source code static concept location support;sv3D tool;visual mappings","","","","0","","16","","","20061009","","IEEE","","IEEE Conference Publications"
"Move code refactoring with dynamic analysis","Kimura, S.; Higo, Y.; Igaki, H.; Kusumoto, S.","Grad. Sch. of Inf. Sci. &amp; Technol., Osaka Univ., Suita, Japan","Software Maintenance (ICSM), 2012 28th IEEE International Conference on","23-28 Sept. 2012","2012","","","575","578","In order to reduce coupling and increase cohesion, we refactor program source code. Previous research efforts for suggesting candidates of such refactorings are based on static analysis, which obtains relations among classes or methods from source code. However, these approaches cannot obtain runtime information such as repetition count of loop, dynamic dispatch and actual execution path. Therefore, previous approaches might miss some refactoring opportunities. To tackle this problem, we propose a technique to find refactoring candidates by analyzing method traces. We have implemented a prototype tool based on the proposed technique and evaluated the technique on two software systems. As a result, we confirmed that the proposed technique could detect some refactoring candidates, which increase code quality.","1063-6773","978-1-4673-2313-0","","10.1109/ICSM.2012.6405324","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6405324","Move Method refactoring;dynamic analysis;refactoring;software maintenance","Cloning;Conferences;Data visualization;Image color analysis;Performance analysis;Software maintenance","program diagnostics;software maintenance;software quality;system monitoring","code quality;dynamic analysis;dynamic dispatch;method traces;program source code refactoring;runtime information;static analysis","","","","0","","8","","","20130110","","IEEE","","IEEE Conference Publications"
"An Eclipse plug-in for the detection of design pattern instances through static and dynamic analysis","De Lucia, A.; Deufemia, V.; Gravino, C.; Risi, M.","Dipt. di Mat. e Inf., Univ. degli Studi di Salerno, Fisciano, Italy","Software Maintenance (ICSM), 2010 IEEE International Conference on","12-18 Sept. 2010","2010","","","1","6","The extraction of design pattern information from software systems can provide conspicuous insight to software engineers on the software structure and its internal characteristics. In this demonstration we present ePAD, an Eclipse plug-in for recovering design pattern instances from object-oriented source code. The tool is able to recover design pattern instances through a structural analysis performed on a data model extracted from source code, and a behavioral analysis performed through the instrumentation and the monitoring of the software system. ePAD is fully configurable since it allows software engineers to customize the design pattern recovery rules and the layout used for the visualization of the recovered instances.","1063-6773","978-1-4244-8630-4","978-1-4244-8628-1","10.1109/ICSM.2010.5609707","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5609707","Eclipse plug-in;design pattern recovery;reverse engineering;source code analysis","","object-oriented programming;program diagnostics;software tools","Eclipse plug-in;design pattern detection;design pattern information extraction;design pattern recovery rules;dynamic analysis;ePAD;object-oriented source code;software engineers;software systems;static analysis","","","","1","","22","","","20101025","","IEEE","","IEEE Conference Publications"
"Constellation visualization: Augmenting program dependence with dynamic information","Fang Deng; DiGiuseppe, N.; Jones, J.A.","Dept. of Inf., Univ. of California, Irvine, Irvine, CA, USA","Visualizing Software for Understanding and Analysis (VISSOFT), 2011 6th IEEE International Workshop on","29-30 Sept. 2011","2011","","","1","8","This paper presents a scalable, statement-level visualization that shows related code in a way that supports human interpretation of clustering and context. The visualization is applicable to many software-engineering tasks through the utilization and visualization of problem-specific meta-data. The visualization models statement-level code relations from a system-dependence-graph model of the program being visualized. Dynamic, run-time information is used to augment the static program model to further enable visual cluster identification and interpretation. In addition, we performed a user study of our visualization on an example program domain. The results of the study show that our new visualization successfully revealed relevant context to the programmer participants.","","978-1-4577-0822-0","978-1-4577-0821-3","10.1109/VISSOF.2011.6069453","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6069453","","Color;Context;Layout;Scalability;Software;Springs;Visualization","data visualisation;graph theory;meta data;pattern clustering;software engineering","constellation visualization;dynamic run-time information;problem-specific meta-data utilization;problem-specific meta-data visualization;program dependence augmentation;scalable statement-level visualization;software-engineering tasks;statement-level code relations;system-dependence-graph model;visual cluster identification;visual cluster interpretation","","","","2","","15","","","20111103","","IEEE","","IEEE Conference Publications"
"Computation and visualization of cause-effect paths","Dubey, A.; Murthy, P.","Software Dev. Improvement Program, ABB Ltd., Bangalore, India","Automation of Software Test (AST), 2013 8th International Workshop on","18-19 May 2013","2013","","","139","145","Static analyzers detect possible run-time errors at compile-time and often employ data-flow analysis techniques to infer properties of programs. Usually, dataflow analysis tools report possible errors with line numbers in source code and leave the task of locating root causes of errors. This paper proposes a technique to aid developers in locating the root causes of statically identified run-time errors with the help of cause-effect paths. A cause effect path terminates at an erroneous statement and originates at the statement which is responsible for the error. We propose modifications to the classic data-flow analysis algorithm to compute cause-effect paths. We discuss different visualization modes in which cause-effect paths can be displayed. As a case study, we implemented a null pointer analyzer, with the additional capability of cause-effect path computation, using the Microsoft Phoenix framework. In addition, we propose a methodology to automatically generate an analyzer which computes cause-effect paths using a framework such as Microsoft Phoenix.","","","","10.1109/IWAST.2013.6595805","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6595805","Static analysis;cause-effect paths;debugging;visualization","Abstracts;Algorithm design and analysis;Arrays;Indexes;Software;Transfer functions;Visualization","data flow analysis;data visualisation","Microsoft Phoenix framework;cause-effect path computation;cause-effect path visualization;compile-time;data-flow analysis techniques;null pointer analyzer;run-time errors;source code;static analyzers","","","","0","","17","","","20130912","","IEEE","","IEEE Conference Publications"
"Dynamic Trace-Based Data Dependency Analysis for Parallelization of C Programs","Lazarescu, M.T.; Lavagno, L.","Politec. di Torino, Turin, Italy","Source Code Analysis and Manipulation (SCAM), 2012 IEEE 12th International Working Conference on","23-24 Sept. 2012","2012","","","126","131","Writing parallel code is traditionally considered a difficult task, even when it is tackled from the beginning of a project. In this paper, we demonstrate an innovative toolset that faces this challenge directly. It provides the software developers with profile data and directs them to possible top-level, pipeline-style parallelization opportunities for an arbitrary sequential C program. This approach is complementary to the methods based on static code analysis and automatic code rewriting and does not impose restrictions on the structure of the sequential code or the parallelization style, even though it is mostly aimed at coarse-grained task-level parallelization. The proposed toolset has been utilized to define parallel code organizations for a number of real-world representative applications and is based on and is provided as free source.","","978-1-4673-2398-7","","10.1109/SCAM.2012.15","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6392110","C program parallelization;C-to-C rewrite;KPN;data dependency analysis;execution trace;graph analysis","Context;Data visualization;Instruments;Libraries;Runtime;Software;Yarn","C language;data analysis;object-oriented programming;parallel programming;pipeline processing;software engineering","C programs;dynamic trace-based data dependency analysis;innovative toolset;parallel code;pipeline-style parallelization;software development","","","","0","","14","","","20121224","","IEEE","","IEEE Conference Publications"
"Synchrovis: 3D visualization of monitoring traces in the city metaphor for analyzing concurrency","Waller, J.; Wulf, C.; Fittkau, F.; Dohring, P.; Hasselbring, W.","Dept. of Comput. Sci., Kiel Univ., Kiel, Germany","Software Visualization (VISSOFT), 2013 First IEEE Working Conference on","27-28 Sept. 2013","2013","","","1","4","The increasing code complexity in modern software systems exceeds the capabilities of most software engineers to understand the system's behavior by just looking at its program code. The addition of concurrency issues through the advent of multi-core processors in the consumer market further escalates this complexity. A solution to these problems is visualizing a model of the system to ease program comprehension. Especially for the comprehension of concurrency issues, static information is often not sufficient. For this purpose, profiling and monitoring can provide additional information on the actual behavior of a system. An established visualization approach is the 3D city metaphor. It utilizes the familiarity with navigating a city to improve program comprehension. In this paper, we present our trace-based SynchroVis 3D visualization approach for concurrency. It employs the city metaphor to visualize both static and dynamic properties of software systems with a focus on illustrating the concurrent behavior. To evaluate our approach, we provide an open source implementation of our concepts and present an exemplary dining philosophers scenario showing its feasibility.","","","","10.1109/VISSOFT.2013.6650520","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6650520","","Buildings;Cities and towns;Concurrent computing;Monitoring;Software systems;Three-dimensional displays;Visualization","concurrency control;data visualisation","3D city metaphor;Synchrovis;code complexity;concurrency issues;concurrent behavior;consumer market;dining philosophers scenario;modern software systems;monitoring traces;multicore processors;program code;software engineers;static information;trace based SynchroVis 3D visualization","","","","0","","15","","","20131031","","IEEE","","IEEE Conference Publications"
"Detecting Security Vulnerabilities with Software Architecture Analysis Tools","Karppinen, K.; Lindvall, M.; Yonkwa, L.","VTT Tech. Res. Centre of Finland, Espoo","Software Testing Verification and Validation Workshop, 2008. ICSTW '08. IEEE International Conference on","9-11 April 2008","2008","","","262","268","Hidden functionality in software is a big problem, because we cannot be sure that the software does not contain malicious code. We conducted an experiment where we studied the relationship between architecture constructs, dynamic behavior and security vulnerabilities. We also studied to what extent architecture analysis tools can assist in detecting security vulnerabilities that are caused by architecture violations. Using the tool, we were able to capture the dynamic pattern of a user breaking in to the system using the back door. Based on the dynamic information in combination with the static information, we obtained a good picture of the ""visual image"" of the back door. Such ""visual images"" can be used to detect vulnerabilities and ultimately help to design software architectures that meet their security requirements.","","978-0-7695-3388-9","","10.1109/ICSTW.2008.14","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4567018","","Best practices;Computer architecture;Documentation;Information security;Software architecture;Software engineering;Software maintenance;Software testing;Software tools;Visualization","security of data;software architecture;software tools","hidden functionality;security vulnerabilities detection;software architecture analysis tools;software architecture design;visual image","","","","3","","9","","","20080716","","IEEE","","IEEE Conference Publications"
"Directions in modelling large-scale software architectures","Grundy, John; Hosking, J.","Dept. of Comput. Sci., Auckland Univ., New Zealand","Software Methods and Tools, 2000. SMT 2000. Proceedings. International Conference on","2000","2000","","","31","40","Modelling the software architectures of large systems is a challenging task. A wide variety of abstractions are required by developers to assist them in describing and analysing such architectures, including information about the components and relationships that comprise a system, the static and dynamic structure of the system, and the behavioural responsibilities of components of the system. In addition, good tool support is needed to provide modelling, analysis, design and code generation, and reverse engineering facilities. This paper analyses several architectural modelling approaches and their tools. Deficiencies with these current approaches are used to motivate a synthesised modelling approach and appropriate tool support","","0-7695-0903-7","","10.1109/SWMT.2000.890418","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=890418","","Application software;Collaboration;Collaborative software;Computer architecture;Large-scale systems;Middleware;Reverse engineering;Software architecture;System analysis and design;Visualization","large-scale systems;reverse engineering;software architecture;software tools;systems analysis","abstractions;behavioural responsibilities;code generation;dynamic structure;large-scale software architecture modelling;reverse engineering facilities;software tool support;static structure;synthesised modelling approach;system components;system design;systems analysis","","","","2","","22","","","20020806","06 Nov 2000-09 Nov 2000","IEEE","","IEEE Conference Publications"
"Industrially validating longitudinal static and dynamic analyses","Holmes, R.; Notkin, D.; Hancock, M.","Sch. of Comput. Sci., Univ. of Waterloo, Waterloo, ON, Canada","User Evaluation for Software Engineering Researchers (USER), 2012","5-5 June 2012","2012","","","43","44","Software systems gradually evolve over time, becoming increasingly difficult to understand as new features are added and old defects are repaired. Some modifications are harder to understand than others; e.g., an explicit method call is usually easy to trace in the source code, while a reflective method call may perplex both developers and analysis tools. Our tool, the Inconsistency Inspector, collects static and dynamic call graphs of systems and composes them to help developers more systematically address the static and dynamic implications of a change to a system.","","978-1-4673-1858-7","","10.1109/USER.2012.6226582","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6226582","","Conferences;Data visualization;Educational institutions;Performance analysis;Runtime;Visualization","graphs;inspection;organisational aspects;program diagnostics;program verification","USER workshop;complex longitudinal data;depth analysis;depth longitudinal evaluation;dynamic analysis;dynamic call graphs;dynamic implications;explicit method;inconsistency inspector;industrial data;industrial organization;industrial utility;industrially validating longitudinal static analysis;reflective method call;software systems;source code;static call graphs;static implications;system change;systems graphs","","","","2","","3","","","20120628","","IEEE","","IEEE Conference Publications"
"CPP2XMI: Reverse Engineering of UML Class, Sequence, and Activity Diagrams from C++ Source Code","Korshunova, E.; Petkovic, M.; van den Brand, M.G.J.; Mousavi, M.R.","Lab. for Quality Software, Technische Universiteit Eindhoven","Reverse Engineering, 2006. WCRE '06. 13th Working Conference on","Oct. 2006","2006","","","297","298","In most cases, reverse engineering is used to retrieve missing design documentation from the source code in the form of an abstract (e.g., UML) model. In the context of this work, reverse engineering is used as a part of the verification and validation chain of software systems, where the static structure and the dynamic behavior of a system are derived from the source code and represented in XML Metadata Interchange (XMI) format. The obtained model is further analyzed for such characteristics as soundness and complexity of the system. XMI is a standard that enables us to express objects using Extensible Markup Language (XML). XMI can be used to represent objects from UML model in XML. In this paper, we describe a reverse engineering tool, CPP2XMI, which allows extracting UML class, sequence, and activity diagrams in XMI format from C++ source code, and its position in the toolset for software system analysis","1095-1350","0-7695-2719-1","","10.1109/WCRE.2006.21","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4024002","","Computer aided software engineering;Data mining;Information filtering;Information filters;Reverse engineering;Software systems;US Department of Transportation;Unified modeling language;Visualization;XML","C++ language;Unified Modeling Language;XML;program diagnostics;program verification;reverse engineering","C++ source code;CPP2XMI;Extensible Markup Language;UML activity diagram;UML class;UML sequence;XML Metadata Interchange;reverse engineering;software system analysis;software systems validation;software systems verification","","","","6","","7","","","20061211","","IEEE","","IEEE Conference Publications"
"A Hybrid Query Engine for the Structural Analysis of Java and AspectJ Programs","Ghanbari, H.; Constantinides, C.; Arnaoudova, V.","Dept. of Comput. Sci. & Software Eng., Concordia Univ., Montreal, QC","Reverse Engineering, 2008. WCRE '08. 15th Working Conference on","15-18 Oct. 2008","2008","","","133","137","Graphical representation has long been used in the domain of software engineering to provide comprehension aids. Generic and query-based code browsers have contributed towards program comprehension through the provision of high-level customized structural views of the source code. Some research has already focused on combining the advantages of the two techniques through the representation of high-level query-based views using different data visualization techniques. However, little has been done towards the visualization of the query composition process itself. In this paper we develop a query engine for software structural analysis which provides a visual query interface over a high-level textual query language to eliminate the requirement for understanding the query language syntax. Our implementation is provided as an Eclipse plug-in, namely HyQ4J (which stands for hybrid query for Java).","1095-1350","978-0-7695-3429-9","","10.1109/WCRE.2008.52","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4656402","Java;codebase;maintenance;query;static analysis;visualization","Computer science;Data visualization;Database languages;Engines;Java;Proposals;Reverse engineering;Software engineering;Software maintenance;Visual databases","Java;object-oriented programming;query languages","AspectJ program;Java;high-level textual query language;hybrid query engine;software structural analysis;visual query interface","","","","0","","26","","","20081024","","IEEE","","IEEE Conference Publications"
"SPLAT: a standard-to-standard real-time graphical scheduling and code generation tool","Van Der Westhuizen, M.J.; Harley, R.G.; Levy, D.C.","Dept. of Electr. Eng., Natal Univ., South Africa","Modeling, Analysis, and Simulation of Computer and Telecommunication Systems, 1995. MASCOTS '95., Proceedings of the Third International Workshop on","18-20 Jan 1995","1995","","","432","435","The paper reports on the development of a software tool which permits the design of real-time systems with the use of standard CAD software. The real-time software is thus in the form of block diagrams which represent optimized function or macros and allows seamless hardware co-design. By using a cyclo-static scheduling model, kernel-less multirate and parallel C code is produced automatically. The software also produces Ganti charts which provide visualization of the real-time behaviour","","0-8186-6902-0","","10.1109/MASCOT.1995.378654","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=378654","","Automatic control;Communication system control;Control systems;Hardware;Parallel processing;Programming;Real time systems;Sampling methods;Switches;Timing","CAD;automatic programming;computer graphics;parallel programming;real-time systems;scheduling;software tools","Ganti charts;SPLAT;block diagrams;code generation tool;cyclo-static scheduling model;kernel-less multirate;macros;optimized function;parallel C code;real-time behaviour visualization;real-time systems design;seamless hardware co-design;software tool;standard CAD software;standard-to-standard real-time graphical scheduling","","","","0","","3","","","20020806","18 Jan 1995-20 Jan 1995","IEEE","","IEEE Conference Publications"
"Enhancing program comprehension with recovered state models","Some, S.S.; Lethbridge, T.C.","Sch. of Inf. Technol. & Eng., Ottawa, Ont., Canada","Program Comprehension, 2002. Proceedings. 10th International Workshop on","2002","2002","","","85","93","State transition machines are high-level behavior descriptions often used as modeling tools for the design and implementation of a large class of software systems. Some of the state transition machine implementation approaches are such that the static structure of the resulting code closely matches that of the original state transition machines. Therefore, having a representation of the original state transition machines is likely to improve the corresponding code understandability. We present an approach supported by a prototype tool, to extract state transition machines by static analysis of source code. An objective of this work is to enhance program comprehension with visual representations of the behavior of the programs being analyzed.","1092-8138","0-7695-1495-2","","10.1109/WPC.2002.1021325","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1021325","","Data mining;Design engineering;Information technology;Navigation;Object oriented modeling;Prototypes;Software maintenance;Software prototyping;Software systems;Software tools","graph theory;program diagnostics;program visualisation;reverse engineering","code understandability;high-level behavior descriptions;modeling tools;program comprehension;recovered state models;software systems;source code;state transition machines;static analysis;static structure;visual representations","","","","2","","","","","20021210","","IEEE","","IEEE Conference Publications"
"Maintenance tools","Oman, P.; Novobilski, A.; Rajlich, V.; Harband, J.; McCabe, T., Jr.; Cross, J., II; Vanek, L.; Davis, L.; Gallagher, K.; Wilde, N.","Idaho Univ., Moscow, ID, USA","Software, IEEE","May 1990","1990","7","3","59","65","After a brief overview, eight tools to help the maintenance programmer analyze and understand code are described in separate presentations. All of them are code-visualization tools. However, while all these tools show how a program is structured, they use different means to achieve different ends. The tools covered are: Objective-C Browser; Vifor; Seela; Battle Map; Act; Grasp/Ada; Expert Dataflow and Static Analysis; Surgeon's Assistant; and Dependency Analysis Tool Set;.<<ETX>>","0740-7459","","","10.1109/52.55229","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=55229","","Costs;Debugging;Displays;Graphical user interfaces;Skeleton;Software tools;Sun;Visual databases;Workstations","software engineering","Act;Battle Map;Dependency Analysis Tool Set;Expert Dataflow;Grasp/Ada;Objective-C Browser;Seela;Static Analysis;Surgeon's Assistant;Vifor;code-visualization tools;maintenance programmer;maintenance tools","","","","10","","","","","20020806","","IEEE","IEEE Computer Society","IEEE Journals & Magazines"
"Combining static and dynamic analysis of concurrent programs","Anger, F.D.; Rodriguez, R.V.; Young, M.","Div. of Comput. Sci., Univ. of West Florida, Pensacola, FL, USA","Software Maintenance, 1994. Proceedings., International Conference on","19-23 Sep 1994","1994","","","89","98","Concurrent systems are inherently more difficult to analyze and visualize than sequential programs. The difficulty of producing correct concurrent programs is mirrored in maintenance as difficulty in extracting a correct high-level model of task interactions and predicting the effect of a modification to portions of a system. We advocate a methodology that combines static analysis of an abstract model with dynamic analysis of source code. While the abstract model is is amenable to exhaustive analysis, dynamic analysis is capable checking richer classes of specifications, and moreover provides a check on the correctness of simplifications and assumptions inherent in abstract models. We illustrate this approach by combining two tools, the PAL system for compositional reachability analyses and the FORESEE analysis tool for temporal analysis of runtime traces, applied to a simulation scenario","","0-8186-6330-8","","10.1109/ICSM.1994.336786","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=336786","","Computer-aided software engineering;Parallel programming;Software debugging;Software design/development;Software maintenance;Software requirements and specifications;Software verification and validation;System analysis and design","formal specification;parallel programming;program debugging;program verification;software maintenance;software tools;systems analysis","FORESEE;PAL system;abstract models;analysis tool;concurrent programs;dynamic analysis;high-level model;methodology;program analysis;program visualization;reachability analyses;runtime traces;sequential programs;simulation;software maintenance;source code;specifications;static analysis;task interactions;temporal analysis","","","","0","2","41","","","20020806","19 Sep 1994-23 Sep 1994","IEEE","","IEEE Conference Publications"
"Alborz: An Interactive Toolkit to Extract Static and Dynamic Views of a Software System","Sartipi, K.; Ye, L.; Safyallah, H.","Dept of Comput. & Software, McMaster Univ., Hamilton, Ont.","Program Comprehension, 2006. ICPC 2006. 14th IEEE International Conference on","0-0 0","2006","","","256","259","Alborz is a multi-view, interactive, and wizard-based software architecture reconstruction and evaluation toolkit that takes advantage of the Eclipse plug-in technology to provide feature extensibility, and uses GXL format to interoperate with other reverse engineering tools. The current version of Alborz toolkit supports static and dynamic views of a software system. For the static view, the toolkit extracts the structure of a software system using wizard-guided forms that allow to define the high-level view of the system. The static view represents abstract components and connectors which are then mapped onto the low-level source graph to find approximate matching within the software system. For the dynamic view, the toolkit extracts high-frequent execution patterns by running feature specific task scenarios on the software system. Subsequently, the implementations of the software features in the source code are identified as a means to evaluate the structure of software. The toolkit will be available as an Eclipse plug-in to serve the software reverse engineering community","1092-8138","0-7695-2601-2","","10.1109/ICPC.2006.8","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1631131","","Connectors;Councils;Information analysis;Java;Packaging;Reverse engineering;Software architecture;Software systems;Software tools;Visualization","object-oriented programming;program diagnostics;reverse engineering;software architecture","Alborz interactive toolkit;Eclipse plug-in technology;GXL format;abstract component;software architecture reconstruction;software reverse engineering tool;software system;static analysis","","","","1","","10","","","20060626","","IEEE","","IEEE Conference Publications"
"Proceedings First International Workshop on Visualizing Software for Understanding and Analysis","","","Visualizing Software for Understanding and Analysis, 2002. Proceedings. First International Workshop on","26-26 June 2002","2002","","","","","The following topics are dealt with: visualizing software for understanding and analysis; view definitions; UML collaboration diagram syntax; class diagrams; task oriented view; component-based software; analogical representations; metrics-based 3D visualization; object oriented software; and data flow.","","0-7695-1662-9","","10.1109/VISSOF.2002.1019788","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1019788","","Object oriented programming;Reverse engineering;System analysis and design","object-oriented programming;program visualisation;reverse engineering;systems analysis","CONCEPT project;UML collaboration diagram syntax;aesthetics;algorithm visualizations;analogical representations;class diagrams;component-based software;data flow;dynamic visualization techniques;language-independent multiple-view program comprehension;language-independent multiple-view program editing;large object-oriented programs;metrics-based 3D visualization;program points;runtime visualisation;software analysis;software understanding;software visualization;source code analysis;static visualization techniques;task oriented view;view definitions;visual execution","","","","0","","","","","20020807","","IEEE","","IEEE Conference Publications"
"A lightweight visualization of interprocedural data-flow paths for source code reading","Ishio, T.; Etsuda, S.; Inoue, K.","Grad. Sch. of Inf. Sci. & Technol., Osaka Univ., Suita, Japan","Program Comprehension (ICPC), 2012 IEEE 20th International Conference on","11-13 June 2012","2012","","","37","46","To understand the behavior of a program, developers must read source code fragments in various modules. For developers investigating data-flow paths among modules, a call graph is too abstract since it does not visualize how parameters of method calls are related to each other. On the other hand, a system dependence graph is too fine-grained to investigate interprocedural data-flow paths. In this research, we propose an intermediate-level of visualization; we visualize interprocedural data-flow paths among method parameters and fields with summarized intraprocedural data-flow paths. We have implemented our visualization as an Eclipse plug-in for Java. The tool comprises a lightweight data-flow analysis and an interactive graph viewer using fractal value to extract a small subgraph of data-flow related to variables specified by a developer. A case study has shown our visualization enabled developers to investigate more data-flow paths in a fixed time slot. In addition, we report our lightweight data-flow analysis can generate precise data-flow paths for 98% of Java methods.","1092-8138","978-1-4673-1213-4","978-1-4673-1215-8","10.1109/ICPC.2012.6240506","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6240506","data-flow analysis;program comprehension;software visualization;static analysis","Approximation methods;Arrays;Control systems;Data visualization;Java;Software;Visualization","Java;data flow analysis;data flow graphs;data visualisation;reverse engineering;source coding","Eclipse plug-in;Java methods;call graph;data-flow analysis;data-flow subgraph;fractal value;interactive graph viewer;interprocedural data-flow paths;lightweight visualization;program behavior understanding;source code fragments;source code reading;system dependence graph;visualization intermediate-level","","","","0","","23","","","20120716","","IEEE","","IEEE Conference Publications"
"YARN: Animating Software Evolution","Hindle, A.; Zhen Ming Jiang; Koleilat, W.; Godfrey, M.W.; Holt, R.C.","Univ. of Waterloo, Waterloo","Visualizing Software for Understanding and Analysis, 2007. VISSOFT 2007. 4th IEEE International Workshop on","24-25 June 2007","2007","","","129","136","A problem that faces the study of software evolution is how to explore the aggregated and cumulative effects of changes that occur within a software system over time. In this paper we describe an approach to modeling, extracting, and animating the architectural evolution of a software system. We have built a prototype tool called YARN (yet another reverse-engineering narrative) that implements our approach; YARN mines the source code changes of the target system, and generates YARN ""balls"" (animations) that a viewer can unravel (watch). The animation is based on a static layout of the modules connected by animated edges that model the changing dependencies. The edges can be weighted by the number of dependencies or the importance of the change. We demonstrate our approach by visualizing the evolution of PostgreSQL DBMS.","","1-4244-0600-5","1-4244-0600-5","10.1109/VISSOF.2007.4290711","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4290711","","Cognitive science;Computer architecture;Data visualization;Facial animation;Prototypes;Software architecture;Software prototyping;Software systems;Watches;Yarn","computer animation;program visualisation;reverse engineering;software architecture;software prototyping","PostgreSQL DBMS;YARN prototype tool;evolution animation;software system architectural evolution;yet another reverse-engineering narrative tool","","","","3","","24","","","20070820","","IEEE","","IEEE Conference Publications"
"A Tool for Visual Understanding of Source Code Dependencies","Pinzger, M.; Grafenhain, K.; Knab, P.; Gall, H.C.","Dept. of Inf., Univ. of Zurich, Zurich","Program Comprehension, 2008. ICPC 2008. The 16th IEEE International Conference on","10-13 June 2008","2008","","","254","259","Many program comprehension tools use graphs to visualize and analyze source code. The main issue is that existing approaches create graphs overloaded with too much information. Graphs contain hundreds of nodes and even more edges that cross each other. Understanding these graphs and using them for a given program comprehension task is tedious, and in the worst case developers stop using the tools. In this paper we present DA4Java, a graph-based approach for visualizing and analyzing static dependencies between Java source code entities. The main contribution of DA4Java is a set of features to incrementally compose graphs and remove irrelevant nodes and edges from graphs. This leads to graphs that contain significantly fewer nodes and edges and need less effort to understand.","1092-8138","978-0-7695-3176-2","","10.1109/ICPC.2008.23","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4556140","Incremental Source Code Analysis;Program Comprehension;Software Visualization;Source Code Dependencies","Costs;Data mining;Informatics;Information filtering;Information filters;Java;Packaging;Software maintenance;Software systems;Visualization","Java;graph theory;program visualisation;reverse engineering","DA4Java;Java source code;graph-based approach;program comprehension tools;source code dependencies;visual understanding","","","","7","","16","","","20080702","","IEEE","","IEEE Conference Publications"
"Dynamic component program visualization","Martin, L.; Giesl, A.; Martin, J.","Dept. of Comput. Sci., Darmstadt Univ. of Technol., Germany","Reverse Engineering, 2002. Proceedings. Ninth Working Conference on","2002","2002","","","289","298","Dynamic program visualization, i.e. the visualization of the runtime behavior of a program as opposed to the static structure of its source code has been investigated for various kinds of programs, usually on a fairly low level. The focus has been on control flow in procedural programs or on the communication between objects in object-oriented programs. In this paper we explore the usefulness of dynamic program visualization for component programs. We discuss how to visualize component-programs and motivate the need for a proper visualization of the communication among these components. We present a three dimensional visualization and show the integration into the HOTAGENT component development environment.","1095-1350","0-7695-1799-4","","10.1109/WCRE.2002.1173086","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1173086","","Application software;Buildings;Communication system control;Computer science;Data visualization;Formal verification;Information analysis;Maintenance;Runtime;Unified modeling language","object-oriented programming;program diagnostics;program visualisation","Dynamic program visualization;HOTAGENT;component development environment;component programs;control flow;program visualization;runtime behavior","","","","3","","","","","20030129","","IEEE","","IEEE Conference Publications"
"Complexity-Aware Adaptive Preprocessing Scheme for Region-of-Interest Spatial Scalable Video Coding","Grois, D.; Hadar, O.","Commun. Syst. Eng. Dept., Ben-Gurion Univ. of the Negev, Beer-Sheva, Israel","Circuits and Systems for Video Technology, IEEE Transactions on","June 2014","2014","24","6","1025","1039","This paper presents a complexity-aware adaptive spatial preprocessing scheme for the efficient scalable video coding (SVC) by employing an adaptive prefilter for each SVC layer. According to the presented scheme, a dynamic transition region is defined between the region of interest (ROI) and background within each video frame, and then various parameters of each prefilter (such as the standard deviation, kernel matrix size, and also a number of filters for the dynamic preprocessing of a transition region between the ROI and the background) are adaptively varied. The presented scheme has proved to be very efficient because it is based on an SVC computational complexity-rate-distortion analysis, thereby adding a complexity dimension to the conventional SVC rate-distortion analysis. As a result, the encoding computational complexity resources are significantly reduced, which is especially useful for portable encoders with limited power resources. The performance of the presented adaptive spatial preprocessing scheme is evaluated and tested in detail from both computational complexity and visual presentation quality points of view, further comparing it with the joint scalable video model reference software (JSVM 9.19) and demonstrating significant improvements.","1051-8215","","","10.1109/TCSVT.2014.2302557","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6727577","High-quality visual presentation;ROI scalability;Regions-of-interest (ROI) video coding;Scalable Video Coding (SVC);high-quality visual presentation;image or video coding;image/video coding;pre-processing/pre-filtering;preprocessing or prefiltering;regions of interest (ROI) video coding;scalable video coding (SVC)","Computational complexity;Encoding;Scalability;Standards;Static VAr compensators;Video coding;Visualization","adaptive filters;computational complexity;rate distortion theory;video codecs;video coding","JSVM 9.19;SVC computational complexity;SVC layer;SVC rate-distortion analysis;adaptive prefilter;adaptive spatial preprocessing scheme;complexity-aware adaptive preprocessing scheme;computational complexity resources;dynamic transition region;joint scalable video model reference software;portable encoders;region-of-interest;scalable video coding;video frame;visual presentation quality","","","","0","","","","2014-01-28","20140602","","IEEE","IEEE Circuits and Systems Society","IEEE Journals & Magazines"
"Complexity-aware adaptive bit-rate control with dynamic ROI pre-processing for scalable video coding","Grois, D.; Hadar, O.","Comm. Syst. Eng., Ben-Gurion Univ. of the Negev, Beer-Sheva, Israel","Multimedia and Expo (ICME), 2011 IEEE International Conference on","11-15 July 2011","2011","","","1","4","We present a novel efficient complexity-aware adaptive bit rate control with dynamic Region-of-Interest pre-processing (pre-filtering) for the Scalable Video Coding (SVC), which is an extension of H.264/AVC. According to the proposed approach, we adaptively vary various parameters of the SVC pre-filters, such as standard deviations and a number of filters for the dynamic pre-processing of a transition region between the ROI and background, thereby enabling to dynamically adjust the desired SVC settings. Our adaptive bit-rate control is based on an SVC computational complexity-rate-distortion (C R-D) analysis, thereby adding a complexity dimension to the conventional Region-of-Interest SVC rate-distortion analysis. As a result, the ROI SVC visual presentation quality is significantly improved, which can be especially useful for various resource-limited devices, such as mobile devices. The performance of the presented adaptive ROI SVC pre processing scheme is evaluated and tested in detail, further comparing it to the Joint Scalable Video Model reference software (JSVM 9.19) and demonstrating significant improvements both in quality and bit-rate.","1945-7871","978-1-61284-348-3","978-1-61284-349-0","10.1109/ICME.2011.6012110","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6012110","H.264/AVC;Regions-of-interest scalability;Regions-of-interest video coding;Scalable Video Coding;bit-rate control;high-quality visual presentation;image/video coding;pre-processing/pre-filtering","Computational complexity;Encoding;Scalability;Static VAr compensators;Video coding;Video sequences;Visualization","computational complexity;filtering theory;rate distortion theory;video coding","H.264/AVC;adaptive bit-rate control;computational complexity;dynamic region-of-interest pre-processing;rate-distortion analysis;scalable video coding;transition region","","","","1","","10","","","20110905","","IEEE","","IEEE Conference Publications"
"Empirical investigation of SEA-based dependence cluster properties","Beszedes, A.; Schrettner, L.; Csaba, B.; Gergely, T.; Jasz, J.; Gyimothy, T.","Dept. of Software Eng., Univ. of Szeged, Szeged, Hungary","Source Code Analysis and Manipulation (SCAM), 2013 IEEE 13th International Working Conference on","22-23 Sept. 2013","2013","","","1","10","Dependence clusters are (maximal) groups of source code entities that each depend on the other according to some dependence relation. Such clusters are generally seen as detrimental to many software engineering activities, but their formation and overall structure are not well understood yet. In a set of subject programs from moderate to large sizes, we observed frequent occurrence of dependence clusters using Static Execute After (SEA) dependences (SEA is a conservative yet efficiently computable dependence relation on program procedures). We identified potential linchpins inside the clusters; these are procedures that can primarily be made responsible for keeping the cluster together. Furthermore, we found that as the size of the system increases, it is more likely that multiple procedures are jointly responsible as sets of linchpins. We also give a heuristic method based on structural metrics for locating possible linchpins as their exact identification is unfeasible in practice, and presently there are no better ways than the brute-force method. We defined novel metrics and comparison methods to be able to demonstrate clusters of different sizes in programs.","","","","10.1109/SCAM.2013.6648178","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6648178","Source code dependence analysis;Static Execute After;dependence clusters;linchpins and linchpin sets","Complexity theory;Conferences;Sea measurements;Software;Software engineering;Visualization","pattern clustering;software engineering;source coding","SEA-based dependence cluster properties;brute-force method;computable dependence relation;dependence relation;linchpin identification;linchpin sets;program procedures;software engineering activities;source code entities;static execute after dependences;structural metrics","","","","1","","20","","","20131028","","IEEE","","IEEE Conference Publications"
"Feature identification: a novel approach and a case study","Antoniol, G.; Gueheneuc, Y.-G.","RCOST, Univ. of Sannio, Italy","Software Maintenance, 2005. ICSM'05. Proceedings of the 21st IEEE International Conference on","26-29 Sept. 2005","2005","","","357","366","Feature identification is a well-known technique to identify subsets of a program source code activated when exercising a functionality. Several approaches have been proposed to identify features. We present an approach to feature identification and comparison for large object-oriented multi-threaded programs using both static and dynamic data. We use processor emulation, knowledge filtering, and probabilistic ranking to overcome the difficulties of collecting dynamic data, i.e., imprecision and noise. We use model transformations to compare and to visualise identified features. We compare our approach with a naive approach and a concept analysis-based approach using a case study on a real-life large object-oriented multi-threaded program, Mozilla, to show the advantages of our approach. We also use the case study to compare processor emulation with statistical profiling.","1063-6773","0-7695-2368-4","","10.1109/ICSM.2005.48","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1510131","Program understanding;dynamic and static analyses;feature analysis;meta-modelling","Computer aided software engineering;Data structures;Emulation;Filtering;Object oriented modeling;Performance analysis;Software maintenance;Software performance;Uniform resource locators;Visualization","multi-threading;object-oriented programming;program diagnostics;program visualisation","Mozilla;concept analysis-based approach;feature identification;knowledge filtering;model transformations;object-oriented multithreaded programs;probabilistic ranking;processor emulation;program source code identification;statistical profiling","","","","24","","23","","","20051121","","IEEE","","IEEE Conference Publications"
"Identifying program, test, and environmental changes that affect behaviour","Holmes, R.; Notkin, D.","Sch. of Comput. Sci., Univ. of Waterloo, Waterloo, ON, Canada","Software Engineering (ICSE), 2011 33rd International Conference on","21-28 May 2011","2011","","","371","380","Developers evolve a software system by changing the program source code, by modifying its context by updating libraries or changing its configuration, and by improving its test suite. Any of these changes can cause differences in program behaviour. In general, program paths may appear or disappear between executions of two subsequent versions of a system. Some of these behavioural differences are expected by a developer; for example, executing new program paths is often precisely what is intended when adding a new test. Other behavioural differences may or may not be expected or benign. For example, changing an XML configuration file may cause a previously-executed path to disappear, which may or may not be expected and could be problematic. Furthermore, the degree to which a behavioural change might be problematic may only become apparent over time as the new behaviour interacts with other changes. We present an approach to identify specific program call dependencies where the programmer's changes to the program source code, its tests, or its environment are not apparent in the system's behaviour, or vice versa. Using a static and a dynamic call graph from each of two program versions, we partition dependencies based on their presence in each of the four graphs. Particular partitions contain dependencies that help a programmer develop insights about often subtle behavioural changes.","0270-5257","978-1-4503-0445-0","978-1-4503-0445-0","10.1145/1985793.1985844","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6032476","comparative analyses;dynamic impact analysis;software behaviour;static analysis","Approximation methods;Data visualization;Educational institutions;Focusing;Libraries;Prototypes;Runtime","directed graphs;program diagnostics","configuration changing;context modification;dynamic call graph;environmental change;library updating;program behaviour;program call dependencies;program identification;program source code;static call graph;test identification","","","","4","","","","","20111010","","IEEE","","IEEE Conference Publications"
"SIP: A Simple Tool for Inspecting and Evaluating WSDL Specifications","Beron, M.; Montejano, G.; Riesco, D.; Henriques, P.R.; Debnath, N.","Inf. Technol. Dept., Univ. Nac. de San Luis, San Luis, Argentina","Information Technology: New Generations (ITNG), 2013 Tenth International Conference on","15-17 April 2013","2013","","","14","19","Understanding a web application is not a simple task. It implies being available to interpret both their descriptions and several systems that really implement the web services. This interpreting process gathers much information and this information must be properly shown for simplifying the understanding. The descriptions of web services are an important starting point to begin to comprehend a web services. They are significant because they offer hints about the web services complexity. The web services complexity can be measured at high level abstraction considering the number of: Services, Ports, Operations, Bindings, etc. In order to carry out the task previously mentioned, the source code of web service description must be analyzed and the information must be properly displayed to the user. In this paper SIP, a Simple Inspection Tool, is described. SIP applies compilation techniques for extracting information from web services and then it computes a set of simple metrics. These metrics are used for providing an idea about web service complexity from its description. Furthermore, SIP generates visualizations based on charts, texts and source codes to help to comprehend WSDL descriptions.","","978-0-7695-4967-5","","10.1109/ITNG.2013.10","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6614282","Metric;Static Analysis;WSDL;Web Services","Complexity theory;Inspection;Measurement;Ports (Computers);Visualization;Web services;XML","Web services;computational complexity;formal specification;information retrieval;program compilers;program visualisation;software metrics;source coding;specification languages;text analysis","SIP;WSDL specification evaluation;WSDL specification inspection;Web service complexity measure;chart;compilation technique;information extraction;simple inspection tool;simple metrics;source code;text analysis;visualization generation","","","","0","","20","","","20130930","","IEEE","","IEEE Conference Publications"
"Fault Localization for Null Pointer Exception Based on Stack Trace and Program Slicing","Shujuan Jiang; Wei Li; Haiyang Li; Yanmei Zhang; Hongchang Zhang; Yingqi Liu","Sch. of Comput. Sci. & Technol., China Univ. of Min. & Technol., Xuzhou, China","Quality Software (QSIC), 2012 12th International Conference on","27-29 Aug. 2012","2012","","","9","12","Null pointer exception is a commonly occurring error in Java programs, and many static analysis tools can identify such errors. However, most of existing tools are pure static analysis and suffer from the common problems of the pure static approaches. In this paper, we present a new approach for identifying null dereferences by combining the dynamically generated information (from the stack trace) with the static analysis. Starting at a dereference statement, where the null pointer exception occurred, our approach performs a backward program slicing guided by the stack trace. Then it performs the null identifying analysis and alias analysis on the sliced program. The approach also visualizes the analysis results and the related source codes. Finally, the paper also presents an implementation of the null pointer exception analysis. The results show the advantage of our approach for locating null pointer exception.","1550-6002","978-1-4673-2857-9","","10.1109/QSIC.2012.36","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6319219","fault localization;null pointer exception;program slicing;stack trace","Accuracy;Algorithm design and analysis;Java;Runtime;Software algorithms;Visualization","Java;program slicing;software fault tolerance","Java programs;alias analysis;dereference statement;fault localization;null pointer exception;program slicing;stack trace;static analysis tools","","","","1","","12","","","20121004","","IEEE","","IEEE Conference Publications"
"Chava: reverse engineering and tracking of Java applets","Korn, J.; Yih-Farn Chen; Koutsofios, E.","Dept. of Comput. Sci., Princeton Univ., NJ, USA","Reverse Engineering, 1999. Proceedings. Sixth Working Conference on","6-8 Oct 1999","1999","","","314","325","Java applets have been used increasingly on Web sites to perform client-side processing and provide dynamic content. While many Web site analysis tools are available, their focus has been on static HTML content and most ignore applet code completely. The paper presents Chava, a system that analyzes and tracks changes in Java applets. The tool extracts information from applet code about classes, methods, fields and their relationships into a relational database. Supplementary checksum information in the database is used to detect changes in two versions of a Java applet. Given our Java data model, a suite of programs that query, visualize, and analyze the structural information were generated automatically from CIAO, a retargetable reverse engineering system. Chava is able to process either Java source files or compiled class files, making it possible to analyze remote applets, whose source code is unavailable. The information can be combined with HTML analysis tools to track both the static and dynamic content of many Web sites. The paper presents our data model for Java and describes the implementation of Chava. Advanced reverse engineering tasks such as reachability analysis, clustering, and program differencing can be built on top of Chava to support design recovery and selective regression testing. In particular, we show how Chava is used to compare several Java Development Kit (JDK) versions to help spot changes that might impact Java developers. Performance numbers indicate that the tool scales well","","0-7695-0303-9","","10.1109/WCRE.1999.806970","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=806970","","Data mining;Data models;Data visualization;HTML;Information analysis;Java;Reachability analysis;Relational databases;Reverse engineering;Visual databases","Java;distributed programming;hypermedia markup languages;information resources;reachability analysis;relational databases;reverse engineering;software maintenance;software tools","CIAO;Chava;HTML analysis tools;Java Development Kit versions;Java applet tracking;Java data model;Java developers;Java source files;Web site analysis tools;Web sites;applet code;client-side processing;clustering;compiled class files;design recovery;dynamic content;program differencing;reachability analysis;relational database;retargetable reverse engineering system;reverse engineering tasks;selective regression testing;static HTML content;structural information;supplementary checksum information","","","","13","","30","","","20020806","06 Oct 1999-08 Oct 1999","IEEE","","IEEE Conference Publications"
"Empirical Study about Using aiT Tool in WCET Estimation","Starke, R.A.; de Oliveira, R.S.","Dept. of Autom. & Syst., Fed. Univ. of Santa Catarina, Florianopolis, Brazil","Computing System Engineering (SBESC), 2011 Brazilian Symposium on","7-11 Nov. 2011","2011","","","86","89","The determination of upper bounds of execution time (Worst-Case Execution Time -- WCET) of tasks is an importantstep in the development and validation of safety-critical hard real-time systems. Measurement based methods arenot considered safe and the static code analysis is know to be a difficult problem if the underling processorarchitecture uses cache memories, pipelines and speculative components. This article presents an empiric study ofthe aiT WCET tool, considered one of the best. There is a tool description, its methods and some analyzed testcode for the ARM7 processor.","","978-1-4673-0427-6","","10.1109/SBESC.2011.42","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6114835","ARM7;Worst-Case Execution Time -- WCET;aiT","Arrays;Ash;Clocks;Pipelines;Real time systems;Visualization","cache storage;multiprocessing systems;pipeline processing;program diagnostics;program testing;reduced instruction set computing;safety-critical software","ARM7 processor;EMPIRICAL STUDY;WCET estimation;aiT WCET tool;cache memories;pipelines;processor architecture;safety-critical hard real-time system development;safety-critical hard real-time system validation;speculative components;static code analysis;worst-case execution time","","","","0","","7","","","20111229","","IEEE","","IEEE Conference Publications"
"Mosaic based representations of video sequences and their applications","Irani, M.; Anandan, P.; Hsu, S.","David Sarnoff Res. Center, Princeton, NJ, USA","Computer Vision, 1995. Proceedings., Fifth International Conference on","20-23 Jun 1995","1995","","","605","611","Recently, there has been a growing interest in the use of mosaic images to represent the information contained in video sequences. The paper systematically investigates how to go beyond thinking of the mosaic simply as a visualization device, but rather as a basis for efficient representation of video sequences. We describe two different types of mosaics called the static and the dynamic mosaic that are suitable for different needs and scenarios. We discuss a series of extensions to these basic mosaics to provide representations at multiple spatial and temporal resolutions and to handle 3D scene information. We describe techniques for the basic elements of the mosaic construction process, namely alignment, integration, and residual analysis. We describe several applications of mosaic representations including video compression, enhancement, enhanced visualization, and other applications in video indexing, search, and manipulation","","0-8186-7042-8","","10.1109/ICCV.1995.466883","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=466883","","Indexing;Information resources;Layout;Software libraries;Spatial resolution;Taxonomy;Tires;Video compression;Video sequences;Visualization","data compression;image coding;image representation;image sequences;video signal processing","3D scene information;dynamic mosaic;mosaic based representations;mosaic construction process;mosaic images;residual analysis;temporal resolutions;video compression;video indexing;video sequences;visualization device","","","","85","27","13","","","20020806","20 Jun 1995-23 Jun 1995","IEEE","","IEEE Conference Publications"
"Source animation as a means of program comprehension for object-oriented systems","Sneed, H.M.","Arget, Germany","Program Comprehension, 2000. Proceedings. IWPC 2000. 8th International Workshop on","2000","2000","","","179","187","Object oriented systems are particularly difficult to comprehend because of the distribution of functionality and polymorphism which limits the effectiveness of conventional static analysis methods. The paper proposes a dynamic analysis approach using animation to simulate the use cases in a financial application system. The objective is to offer maintenance programmers a means of familiarizing themselves with complex C++ code while at the same time validating the correctness of the code. For this purpose, control flow slicing and concept lattices are used","1092-8138","0-7695-0656-9","","10.1109/WPC.2000.852492","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=852492","","Analytical models;Animation;Assembly;Delay;Dynamic programming;Lattices;Object oriented modeling;Object oriented programming;Programming profession;Runtime","C++ language;computer animation;financial data processing;object-oriented programming;program verification;program visualisation;reverse engineering;software maintenance","complex C++ code;concept lattices;control flow slicing;conventional static analysis methods;correctness validation;dynamic analysis approach;financial application system;maintenance programmers;object oriented systems;polymorphism;program comprehension;source animation;use case simulation","","","","0","","24","","","20020806","10 Jun 2000-11 Jun 2000","IEEE","","IEEE Conference Publications"
"eFlowMining: An Exception-Flow Analysis Tool for .NET Applications","Garcia, I.; Cacho, N.","Dept. de Eng. de Producao, Fed. Univ. of Rio Grande do Norte, Natal, Brazil","Dependable Computing Workshops (LADCW), 2011 Fifth Latin-American Symposium on","25-29 April 2011","2011","","","1","8","In this paper, we present a exception-flow analysis tool, called eFlow Mining, that automates the process of gathering and visualizing exception-handling constructs in multi-programming languages. More specifically, the current version of eFlow Mining focuses on code written using the .NET framework to help developers in inspecting applications either to improve them or to understand their exception handling behavior. eFlow Mining extracts metrics and information about the exception flows in. NET applications, providing different views of the exception handling. For instance, an Evolution View allows developers to visualize the behavior of multiple metrics over the application history. Use of this tool on five. NET applications demonstrates that the tool can be helpful to support developers building and evolving applications with appropriate error-handling strategies.","","978-1-4577-0194-8","978-0-7695-4394-9","10.1109/LADCW.2011.18","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5773431","Exception Handling;Software Evolution;Static Analysis","Computer languages;Documentation;History;Libraries;Measurement;Runtime;Software","data flow analysis;exception handling;network operating systems;program visualisation;programming languages;software maintenance",".NET application;Evolution View;behavior visualization;eFlowMining;error-handling strategy;exception handling behavior;exception-flow analysis tool;multiprogramming language;software evolution;static analysis","","","","3","","26","","","20110527","","IEEE","","IEEE Conference Publications"
"Automatic Conceptual Analysis of User Requirements with the Requirements Engineering Assistance Diagnostic (READ) Tool","Seresht, S.M.; Ormandjieva, O.; Sabra, S.","Comput. Sci. & Software Eng. Dept., Concordia Univ., Montreal, QC","Software Engineering Research, Management and Applications, 2008. SERA '08. Sixth International Conference on","20-22 Aug. 2008","2008","","","133","142","This paper describes an elaborate methodology that constitutes a proof of concept for the idea that a conceptual knowledge on the software to be developed can be acquired through an automated process, with a corpus of textual requirement documents as input and diagrams representing its static (domain model) and dynamic (context use-case model) aspects, as output. An improved domain model is generated by injecting domain-related missing information provided by Expert Comparable Contextual (ECC) models, which are extracted from reusable domain-specific data models. The dynamic view abstracts the main functionalities of the software as a context use-case model. The paper describes the architecture of the Requirements Engineering Assistance Diagnostic (READ) tool implementing our methodology which will guide the developers in their in-depth study of the requirements text and in the timely identification of risks that poorly specified requirements might introduce into the project.","","978-0-7695-3302-5","","10.1109/SERA.2008.34","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4609419","Automated Process;Conceptual Analysis Modeling;Requirements Engineering","Application software;Conference management;Context modeling;Data mining;Data models;Error correction codes;Programming;Quality assessment;Software engineering;Visualization","program diagnostics;program verification;systems analysis;text analysis","ECC models;READ tool;automatic conceptual analysis;conceptual knowledge;context use-case model aspects;expert comparable contextual models;requirements engineering assistance diagnostic tool;textual requirement documents;user requirements","","","","0","","17","","","20080829","","IEEE","","IEEE Conference Publications"
"Type Highlighting: A Client-Driven Visual Approach for Class Hierarchies Reengineering","Mihancea, P.F.","LOOSE Res. Group, Univ. of Timisoara, Timisoara","Source Code Analysis and Manipulation, 2008 Eighth IEEE International Working Conference on","28-29 Sept. 2008","2008","","","207","216","Polymorphism and class hierarchies are key to increasing the extensibility of an object-oriented program but also raise challenges for program comprehension. Despite many advances in understanding and restructuring class hierarchies, there is no direct support to analyze and understand the design decisions that drive their polymorphic usage. In this paper we introduce a metric-based visual approach to capture the extent to which the clients of a hierarchy polymorphically manipulate that hierarchy. A visual pattern vocabulary is also presented in order to facilitate the communication between analysts. Initial evaluation shows that our techniques aid program comprehension by effectively visualizing large quantities of information, and can help detect several design problems.","","978-0-7695-3353-7","","10.1109/SCAM.2008.16","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4637553","class hierarchies;metrics;polymorphism;software visualization;static analysis","Aging;Data analysis;Pattern analysis;Performance analysis;Printing;Reverse engineering;Software maintenance;Software quality;Visualization;Vocabulary","object-oriented programming;polymorphism;program diagnostics;program visualisation;software maintenance","class hierarchy reengineering;client-driven visual approach;object-oriented program;polymorphism;program comprehension;software maintenance;static analysis;visual pattern vocabulary","","","","3","","21","","","20081003","","IEEE","","IEEE Conference Publications"
"Representing and Integrating Dynamic Collaborations in IDEs","Rothlisberger, D.; Greevy, O.","Software Composition Group, Univ. of Bern, Bern","Reverse Engineering, 2008. WCRE '08. 15th Working Conference on","15-18 Oct. 2008","2008","","","74","78","Static views of object-oriented source code as presented in a development environment (IDE) do not provide explicit representations of dynamic collaboration to describe how source artifacts communicate at runtime. Direct access within an IDE to explicit representations of dynamic collaborations would provide developers with useful insights into a system's behavior. In this paper we describe how we seamlessly integrate novel interactive visual representations of dynamic collaborations between static artifacts to complement traditional static concepts within the IDE. We motivate our work and introduce our enhancements in our prototype IDE Hermion and provide validation for our work by means of case studies and benchmarks.","1095-1350","978-0-7695-3429-9","","10.1109/WCRE.2008.53","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4656396","development environments;dynamic analysis;dynamic collaborations;partial behavioral reflection;program comprehension","Collaboration;Collaborative software;Collaborative work;Displays;Navigation;Prototypes;Runtime environment;Software systems;Unified modeling language;Visualization","object-oriented programming;program diagnostics;program visualisation;software engineering","integrated development environment;interactive visual dynamic collaboration representation;object-oriented source code;software developer;static view;system behavior","","","","1","","12","","","20081024","","IEEE","","IEEE Conference Publications"
