01. Using static code analysis tools to increase source code maintainability
02. An effective visual system for static analysis of source code
03. Software metrics in static program analysis
06. Visualization tools for understanding a complex code from a real application
09. Magnify - A new tool for software visualization
11. Software visualization in software maintenance, reverse engineering, and re-engineering: A research survey
13. A lightweight visualization of interprocedural data-flow paths for source code reading
16. Case study: Visual analytics in software product assessments
17. Visual exploration of function call graphs for feature location in complex software systems
18. Static analysis of programs with graphical user interface
20. Characterising, explaining, and exploiting the approximate nature of static analysis through animation
23. Analyzing Java software by combining metrics and program visualization
26. Visualization of C++ template metaprograms
31. Fast analysis of source code in C and C++
35. Support for static concept location with sv3D
47. Concurrent object-oriented programming: A visualization challenge
56. Socialization in an open source software community: A socio-technical analysis
57. Information visualisation utilising 3D computer game engines case study: A source code comprehension tool
58. The SourceGraph program
95. Chava: Reverse engineering and tracking of Java applets

5 mais importantes:

01. Using static code analysis tools to increase source code maintainability (-)

Source: MIPRO 2009 - 32nd International Convention Proceedings: Telecommunications and Information, v 2, p
145-148, 2009, MIPRO 2009 - 32nd International Convention Proceedings: Telecommunications and Information;

Abstract: There are a lot of static code analysis tools to automatically find program faults. These tools can analyze
software without actually executing the programs. Code analysis tools can play an essential role in creating secure
and reliable software. They can help catch common coding mistakes such as buffer overflow, cross-site scripting,
Structured Query Language (SQL) injections, and a variety of race conditions. They also can help write code which is
easier to maintain. The purpose of this paper is to present tools for static code analysis on C# language and how can
be these tools used to help write more maintainable code. In experimental part we evaluate code before and after use
of tools with maintainability index defined by Oman and Hagemeister. (9 refs)

02. An effective visual system for static analysis of source code (+)

Source: Advanced Materials Research, v 433-440, p 5453-5458, 2012, Materials Science and Information Technology,
MSIT2011; ISSN: 10226680; ISBN-13: 9783037853191; DOI: 10.4028/www.scientific.net/AMR.433-440.5453;

Abstract: In the software development lifecycle, code static analysis takes an important part in building secure
software. To help discover the potential security issues in source code, large numbers of static analysis tools are
developed. But the results generated by them display in the form of pure text, so it is time-consuming for developers
to analyze these text messages, and it is difficult for developers to concentrate on the most interesting defects in huge
data. In this paper, we have developed a visualization system oriented to Java source code, which presents the results
in graphics from a developer's point of view, to help developers to analysis code defects. A novel layout is proposed
to visualize software source code in a hierarchy way, which shows the physical structure of the software. A visual
overview and powerful interaction is provided in this system which allows the developer to focus on the most pressing
defects within huge volumes of source code. © (2012) Trans Tech Publications, Switzerland. (9 refs)

03. Software metrics in static program analysis (-)

Source: Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and
Lecture Notes in Bioinformatics), v 6447 LNCS, p 485-500, 2010, Formal Methods and Software Engineering - 12th
International Conference on Formal Engineering Methods, ICFEM 2010, Proceedings; ISSN: 03029743, E-ISSN:
16113349; ISBN-10: 3642169007, ISBN-13: 9783642169007; DOI: 10.1007/978-3-642-16901-4_32; Conference:
12th International Conference on Formal Engineering Methods, ICFEM 2010, November 17, 2010 - November 19,
2010; Publisher: Springer Verlag

Abstract: Software metrics play an important role in the management of professional software projects. Metrics are
used, e.g., to track development progress, to measure restructuring impact and to estimate code quality. They are
most beneficial if they can be computed continuously at development time. This work presents a framework and an
implementation for integrating metric computations into static program analysis. The contributions are a language and
formal semantics for user-definable metrics, an implementation and integration in the existing static analysis tool ,
and a user-definable visualization approach to display metrics results. Moreover, we report our experiences on a case
study of a popular open source code base. © 2010 Springer-Verlag Berlin Heidelberg. (16 refs)

06. Visualization tools for understanding a complex code from a real application (-)

Source: 22nd International Conference on Computer Applications in Industry and Engineering 2009, CAINE 2009, p
284-291, 2009, 22nd International Conference on Computer Applications in Industry and Engineering 2009, CAINE
2009; ISBN-13: 9781615676668; Conference: 22nd International Conference on Computer Applications in Industry
and Engineering 2009, CAINE 2009, November 4, 2009 - November 6, 2009; Publisher: International Society for
Computers and Their Applications

Abstract: Research in Magnetic Resonance Imaging (MRI) requires researchers to make changes to the software that
controls the scanner. Thus, the first challenge faced by MRI researchers is to understand the scanner's code to find
the places where the changes must be made, and to make sure that the changes will not produce undesired effects in
other parts of the code. At the Biomedical Imaging Center at Pontificia Universidad Cato ́lica de Chile, we have been
developing visualization tools for analysing the Philips scanner's code, and for storing and sharing the know-how thus
acquired. We devised the tools to help MRI researchers identify the code's main concerns and understand how these
concerns are represented and handled within the code. In this paper we report on the tools' functionalities; e.g., finding
the places where each object or function is used, analyzing relationships among objects, storing comments to objects
and functions, identifying which functions are executed and in which order, representing this information as a tree,
searching this tree for a given function, and highlighting the differences between the trees representing two different
executions. Initial tests show that these tools effectively support MRI researchers in their task of understanding the
scanner's code. (11 refs)

11. Software visualization in software maintenance, reverse engineering, and re-engineering: A research survey (+)

Source: Journal of Software Maintenance and Evolution, v 15, n 2, p 87-109, March/April 2003; ISSN: 1532060X; DOI:
10.1002/smr.270; Publisher: John Wiley and Sons Ltd

Abstract: Software visualization is concerned with the static visualization as well as the animation of software
artifacts, such as source code, executable programs, and the data they manipulate, and their attributes, such as size,
complexity, or dependencies. Software visualization techniques are widely used in the areas of software maintenance,
reverse engineering, and re-engineering, where typically large amounts of complex data need to be understood and
a high degree of interaction between software engineers and automatic analyses is required. This paper reports
the results of a survey on the perspectives of 82 researchers in software maintenance, reverse engineering, and
re-engineering on software visualization. It describes to which degree the researchers are involved in software
visualization themselves, what is visualized and how, whether animation is frequently used, whether the researchers
believe animation is useful at all, which automatic graph layouts are used if at all, whether the layout algorithms
have deficiencies, and - last but not least - where the medium-term and long-term research in software visualization
should be directed. The results of this survey help to ascertain the current role of software visualization in software
engineering from the perspective of researchers in these domains and give hints on future research avenues. (24 refs)

13. A lightweight visualization of interprocedural data-flow paths for source code reading (-)

Source: IEEE International Conference on Program Comprehension, p 37-46, 2012, 2012 20th IEEE International
Conference on Program Comprehension, ICPC 2012 - Proceedings; ISBN-13: 9781467312165; Article number:
6240506;

Abstract: To understand the behavior of a program, developers must read source code fragments in various modules.
For developers investigating data-flow paths among modules, a call graph is too abstract since it does not visualize
how parameters of method calls are related to each other. On the other hand, a system dependence graph is too
fine-grained to investigate interprocedural data-flow paths. In this research, we propose an intermediate-level of
visualization; we visualize interprocedural data-flow paths among method parameters and fields with summarized
intraprocedural data-flow paths. We have implemented our visualization as an Eclipse plug-in for Java. The tool
comprises a lightweight data-flow analysis and an interactive graph viewer using fractal value to extract a small
subgraph of data-flow related to variables specified by a developer. A case study has shown our visualization enabled
developers to investigate more data-flow paths in a fixed time slot. In addition, we report our lightweight data-flow
analysis can generate precise data-flow paths for 98% of Java methods. © 2012 IEEE. (23 refs)

18. Static analysis of programs with graphical user interface (-)

Source: Proceedings of the European Conference on Software Maintenance and Reengineering, CSMR, p 252-261,
2007, Proceedings - CSMR 2007: 11th European Conference on Software Maintenance and Reengineering - Software
Evolution in Complex Software Intensive Systems; ISSN: 15345351; DOI: 10.1109/CSMR.2007.44; Article number:
4145043;

Abstract: We describe a new approach for statically analyzing programs which have a graphical user interface
(GUI). Our analysis detects the parts of the program which belong to the GUI, it detects widgets and hierarchies they
form, and it shows the event handlers connected to events of those widgets. Besides supporting general program
understanding, we show that this also supports control-flow analysis, architecture recovery, migration to GUI builders
and mapping the visual appearance of the program to source code arte-facts. Our tests indicate that the static analysis
we propose is fast and useful. © 2007 IEEE. (23 refs)

23. Analyzing Java software by combining metrics and program visualization (-)

Source: Proceedings of the European Conference on Software Maintenance and Reengineering, CSMR, p 199-208,
2000;

Abstract: Shimba, a prototype reverse engineering environment, has been built to support the understanding of
Java software. Shimba uses Rigi and SCED to analyze, visualize, and explore the static and dynamic aspects,
respectively, of the subject system. The static software artifacts and their dependencies are extracted from Java
byte code and viewed as directed graphs using the Rigi reverse engineering environment. The static dependency
graphs of a subject system can be annotated with attributes, such as software quality measures, and then be analyzed
and visualized using scripts through the end-user programmable interface. Shimba has recently been extended with
the Chidamber and Kemerer suite of object-oriented metrics. The metrics measure properties of the classes, the
inheritance hierarchy, and the interaction among classes of a subject system. Since Shimba is primarily intended
for the analysis and exploration of Java software, the metrics have been tailored to measure properties of software
components written in Java. We show how these metrics can be applied in the context of understanding software
systems using a reverse engineering environment. The static dependency graphs of the system under investigation
are decorated with measures obtained by applying the object-oriented metrics to selected software components.
Shimba provides tools to examine these measures, to find software artifacts that have values that are in a given range,
and to detect correlations among different measures. The object-oriented analysis of the subject Java system can be
investigated further by exporting the measures to a spreadsheet. (25 refs)

26. Visualization of C++ template metaprograms (-)

Source: Proceedings - 10th IEEE International Working Conference on Source Code Analysis and Manipulation,
SCAM 2010, p 167-176, 2010, Proceedings - 10th IEEE International Working Conference on Source Code Analysis
and Manipulation, SCAM 2010; ISBN-13: 9780769541785; DOI: 10.1109/SCAM.2010.16; Article number: 5601850;

Abstract: Template metaprograms have become an essential part of today's C++ programs: with proper template
definitions we can force the C++ compiler to execute algorithms at compilation time. Among the application areas of
template metaprograms are the expression templates, static interface checking, code optimization with adaptation,
language em- bedding and active libraries. Despite all of its already proven benefits and numerous successful
applications there are surprisingly few tools for creating, supporting, and ana- lyzing C++ template metaprograms. As
metaprograms are executed at compilation time they are even harder to under- stand. In this paper we present a code
visualization tool, which is utilizing Templight, our previously developed C++ template metaprogram debugger. Using
the tool it is pos- sible to visualize the instantiation chain of C++ templates and follow the execution of metaprograms.
Various presen- tation layers, filtering of template instances and step-by- step replay of the instantiations are
supported. Our tool can help to test, optimize, maintain C++ template metapro- grams, and can enhance their
acceptance in the software industry. © 2010 IEEE. (28 refs)

31. Fast analysis of source code in C and C++ (+)

Source: Programming and Computer Software, v 39, n 1, p 49-55, January 2013; ISSN: 03617688; DOI: 10.1134/
S0361768813010064; Publisher: Maik Nauka-Interperiodica Publishing

Abstract: Static analysis is a popular tool for detecting the vulnerabilities that cannot be found by means of ordinary
testing. The main problem in the development of static analyzers is their low speed. Methods for accelerating such
analyzers are described, which include incremental analysis, lazy analysis, and header file caching. These methods
make it possible to considerably accelerate the detection of defects and to integrate the static analysis tools in the
development environment. As a result, defects in a file edited in the Visual Studio development environment can be
detected in 0.5 s or faster, which means that they can be practically detected after each keystroke. Therefore, critical
vulnerabilities can be detected and corrected at the stage of coding. © Pleiades Publishing, Ltd., 2013. (8 refs)

57. Information visualisation utilising 3D computer game engines case study: A source code comprehension tool (-) **ler isso**

Source: ACM International Conference Proceeding Series, v 94, p 53-60, 2005, Proceedings - CHINZ 2005 - Making
CHI Natural: 6th International Conference NZ Chapter of the ACM's Special Interest Group on Computer-Human
Interaction (SIGCHI-NZ); ISBN-10: 1595930361, ISBN-13: 9781595930361; DOI: 10.1145/1073943.1073954;

Abstract: Information visualisation applications have been facing ever-increasing demands as the amount of available
information has increased exponentially. With this, the number and complexity of visualisation tools for analysing and
exploring data has also increased dramatically, making development and evolution of these systems difficult. We
describe an investigation into reusing technology developed for computer games to create collaborative information
visualisation tools. A framework for using game engines for information visualisation is presented together with
an analysis of how the capabilities and constraints of a game engine influence the mapping of data into graphical
representations and the interaction with it. Based on this research a source code comprehension tool was implemented
using the Quake 3 computer game engine. It was found that game engines can be a good basis for an information
visualisation tool, provided that the visualisations and interactions required meet certain criteria, mainly that the
visualisation can be represented in terms of a limited number of discrete, interactive, and physical entities placed in a
static 3-dimensional world of limited size. Copyright 2005 ACM. (31 refs)


58. The SourceGraph program

38. Seesoft--A tool for visualizing line oriented software statistics (+)
Eick, Stephen G. ; Steffen, Joseph L. ; Sumner Jr., Eric E.
Source: IEEE Transactions on Software Engineering, v 18, n 11, p 957-968, Nov 1992; ISSN: 00985589; DOI:
10.1109/32.177365
Abstract: The Seesoft software visualization system allows one to analyze up to 50,000 lines of code simultaneously
by mapping each line of code into a thin row. The color of each row indicates a statistic of interest, e.g., red rows are
those most recently changed, and blue are those least recently changed. Seesoft displays data derived from a variety
of sources, such as version control systems that track the age, programmer, and purpose of the code (e.g., control
ISDN lamps, fix bug in call forwarding); static analyses, (e.g., locations where functions are called); and dynamic
analyses (e.g., profiling). By means of direct manipulation and high interaction graphics, the user can manipulate this
reduced representation of the code in order to find interesting patterns. Further insight is obtained by using additional
windows to display the actual code. Potential applications for Seesoft include discovery, project management, code
tuning, and analysis of development methodologies. (20 refs)

46. Cognitive design elements to support the construction of a mental model during (+)
software exploration
Storey, M.-A.D. (1); Fracchia, F.D. (1); Muller, H.A. (1)
Source: Journal of Systems and Software, v 44, n 3, p 171-185, Jan 1 1999; ISSN: 01641212; DOI: 10.1016/
S0164-1212(98)10055-9; Publisher: Elsevier Science Inc
Author affiliation: (1) Simon Fraser Univ, Burnaby, Canada
Abstract: The scope of software visualization tools which exist for the navigation, analysis and presentation of
software information varies widely. One class of tools, which we refer to as Software exploration tools, provides
graphical representations of static software structures linked to textual views of the program source code and
documentation. This paper describes a hierarchy of cognitive issues which should be considered during the design of
a software exploration tool. The hierarchy of cognitive design elements is derived through the examination of program
comprehension cognitive models. Examples of how existing tools address each of these issues are provided. In
addition, this paper demonstrates how these cognitive design elements may be applied to the design of an effective
interface for software exploration. (72 refs)

60. Maintenance tools (+)

Oman, Paul (1); Novobilski, Andrew (1); Rajlich, Vaclav (1); Harband, Joel (1); McCabe Jr., Thomas (1); Cross, James
(1); Vanek, Leonard (1); Davis, Linda (1); Gallagher, Keith (1); Wilde, Norman (1)
Source: IEEE Software, v 7, n 3, p 59-65, May 1990; ISSN: 07407459; DOI: 10.1109/52.55229
Author affiliation: (1) Univ of Idaho, Idaho, ID, USA
Abstract: After a brief overview by P. Oman, eight tools to help the maintenance programmer analyze and understand
code are described in separate presentations. All of them are code-visualization tools. However, while all these
tools show how a program is structured, they use different means to achieve different ends. The tools covered are:
Objective-C Browser; Vifor; Seela; Battle Map; Act; Grasp/Ada; Expert Dataflow and Static Analysis; Surgeon's
Assistant; and Dependency Analysis Tool Set.

